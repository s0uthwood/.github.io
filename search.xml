<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>First Crypto</title>
    <url>/2020/11/15/First-Crypto/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间学习信安数基，助教学长就配套出了道Quiz，来给我们练手。这两天决定记录一下学习过程，就拿来来给博客练手（手动狗头）。</p>
<a id="more"></a>
<p><del>一个大四的老同志，来，出题，来，欺负，我们大二的小学弟，这好吗？这不好。还好我是有备而来</del></p>
<p>废话说到这里，先上题目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> getRandomNBitInteger</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> getPrime</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> isPrime</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> inverse</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPrime</span>(<span class="params">n</span>):</span></span><br><span class="line">    n += <span class="number">2</span> <span class="keyword">if</span> n &amp; <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> isPrime(n):</span><br><span class="line">        n += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>(<span class="params">S, K</span>):</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    k = []</span><br><span class="line">    K = <span class="built_in">list</span>(K)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(K)):</span><br><span class="line">        K[i] = <span class="built_in">ord</span>(K[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        S.append(i)</span><br><span class="line">        k.append(K[i % <span class="built_in">len</span>(K)])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + S[i] + k[i]) % <span class="number">256</span></span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Encrypt</span>(<span class="params">key, D</span>):</span></span><br><span class="line">    S=[]</span><br><span class="line">    init(S, key)</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> D:</span><br><span class="line">        a = <span class="built_in">ord</span>(a)</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + S[i]) % <span class="number">256</span></span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line">        k = <span class="built_in">chr</span>(a ^ S[(S[i] + S[j]) % <span class="number">256</span>])</span><br><span class="line">        result += k</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Decrypt</span>(<span class="params">key, D</span>):</span></span><br><span class="line">    S = []</span><br><span class="line">    init(S, key)</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> D:</span><br><span class="line">        a = <span class="built_in">ord</span>(a)</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + S[i]) % <span class="number">256</span></span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line">        k = <span class="built_in">chr</span>(a ^ S[(S[i] + S[j]) % <span class="number">256</span>])</span><br><span class="line">        result += k</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    key = long_to_bytes(getRandomNBitInteger(<span class="number">100</span>))</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;key =&#x27;</span>, bytes_to_long(key)</span><br><span class="line">    e = getPrime(<span class="number">512</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;e =&#x27;</span>, e</span><br><span class="line"></span><br><span class="line">    E = nextPrime(e)</span><br><span class="line">    f = math.factorial(e) % E</span><br><span class="line"></span><br><span class="line">    d = long_to_bytes(f)</span><br><span class="line"></span><br><span class="line">    c1 = bytes_to_long(Encrypt(key, d))</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;c1 =&#x27;</span>, c1</span><br><span class="line"></span><br><span class="line">    c2 = bytes_to_long(Encrypt(key, flag))</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;c2 =&#x27;</span>, c2</span><br><span class="line"></span><br><span class="line"><span class="comment"># e = 11248112333656902878308992204660514716130692202019193081806766887380465145401754698746718075268681481388695805324253817155823465013590321091178897918430457</span></span><br><span class="line"><span class="comment"># c1 = 11792816667683654209610238149228683194178884298019505853565076663183883681365400495420305428570416004628438524072440231323696408946395141935772862600031614</span></span><br><span class="line"><span class="comment"># c2 = 81946333492800053045881242964212560642046177081574600318494251620269838444004879162713842</span></span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先阅读主函数部分，显然这道题需要先通过e, E求解f，以此得到d，随后再利用d, c1, c2来求解flag。</p>
<h2 id="求解f"><a href="#求解f" class="headerlink" title="求解f"></a>求解f</h2><p>题目中的$f=e!\mathrm{mod} E$ ，但由于e过大，显然无法直接计算得到。观察发现，$e!$ 当中的绝大多数部分可以两两配对组成模$E$的逆元，因此猜测可能存在类似于$(E-1)!\equiv 1\ (\mathrm{mod}\ E)$ 的规律，如果满足这个规律，我们就可以通过计算$\prod\limits_{i=e+1}^{E-1}i\ (\mathrm{mod}\ E)$ 的逆元得到f。</p>
<p>经过几次简单的检验，猜测规律为$(E-2)!\equiv 1\ (\mathrm{mod}\ E)$ （后得知为Wilson定理，当时还没学…），因此只需要计算$tmp\equiv \prod\limits_{i=e+1}^{E-2}i\ (\mathrm{mod}\ E),\ f\cdot tmp\equiv 1\ (\mathrm{mod}\ E)$ 即可得到$f$。</p>
<h2 id="求解flag"><a href="#求解flag" class="headerlink" title="求解flag"></a>求解flag</h2><p>得到了 f 后，可以直接利用<code>long_to_bytes(f)</code>来得到 d 。为求解 flag，初步设想为利用加密函数求解 key，随后直接利用解密函数求解 flag。阅读<code>Encrypt</code>函数和<code>Decrypt</code>函数后发现加解密函数完全一致，且实际的加解密过程只有异或运算，说明 d 到 c1 的运算步骤与 flag 到 c2 的运算步骤完全相同且可逆，因此求解时没必要求出 key。进一步分析后发现加密算法大致是将 key 转化成某个固定的数组，并与明文依次进行异或运算得到密文，也就是说经过了 init 函数和多次交换位置（交换的次序也是固定的）后的数列才是真正的密钥。</p>
<p>因此，只需要将 c1, c2 和 d 转换成 bytes，然后对每一位取 <code>ord</code> 后进行异或运算，组成的数字取 <code>chr</code> 后加到答案字符串后面，即可得到 flag。</p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> AITMCLab.libnum.modular <span class="keyword">import</span> invmod</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> isPrime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPrime</span>(<span class="params">n</span>):</span></span><br><span class="line">    n += <span class="number">2</span> <span class="keyword">if</span> n &amp; <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> isPrime(n):</span><br><span class="line">        n += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    e = <span class="number">11248112333656902878308992204660514716130692202019193081806766887380465145401754698746718075268681481388695805324253817155823465013590321091178897918430457</span></span><br><span class="line">    c1 = <span class="number">5120829596353532760839054347975234579355835073413768618360492980516438193909447500996222328143719619379838946544412967584025416378147246422705451415437468</span></span><br><span class="line">    c2 = <span class="number">17985907282297772406857113433926323639543183645704827789984971602150950301590677893419082</span></span><br><span class="line">    E = nextPrime(e)</span><br><span class="line">    f_1 = <span class="number">1</span></span><br><span class="line">    i = e + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; E - <span class="number">1</span>:</span><br><span class="line">        f_1 *= i</span><br><span class="line">        f_1 %= E</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    f = invmod(f_1, E)</span><br><span class="line">    <span class="comment"># 以上为求解f的过程</span></span><br><span class="line">    d = long_to_bytes(f)</span><br><span class="line">    c1_bytes = long_to_bytes(c1)</span><br><span class="line">    c2_bytes = lone_to_bytes(c2)</span><br><span class="line">    flag = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c2_bytes)):</span><br><span class="line">        flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(c2_bytes[i]) ^ <span class="built_in">ord</span>(c1_bytes[i]) ^ <span class="built_in">ord</span>(d[i]))</span><br><span class="line">    <span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure>
<h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>flag{Congratulation!_quiz1_passed!!!}</p>
]]></content>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>My Latex Cheatsheet</title>
    <url>/2020/11/15/My-Latex-Cheatsheet/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>整理一下自己用过的latex命令。</p>
<p><del>先占个坑，还没想好怎么写…</del></p>
<p>现在想好怎么写了，慢慢填坑吧。。。</p>
<a id="more"></a>
<h1 id="标题及基础设置"><a href="#标题及基础设置" class="headerlink" title="标题及基础设置"></a>标题及基础设置</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[a4paper, zihao=-4, UTF8]&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\CTEXsetup</span>[format=&#123;<span class="keyword">\Large</span><span class="keyword">\bfseries</span>&#125;]&#123;section&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\pagesytle</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">	<span class="keyword">\maketitle</span></span><br><span class="line">	<span class="keyword">\section</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">\section</span>[short title]&#123;&#125;</span><br><span class="line">	<span class="keyword">\label</span>&#123;sec:section<span class="built_in">_</span>with<span class="built_in">_</span>short<span class="built_in">_</span>title&#125;</span><br><span class="line">	section <span class="keyword">\ref</span>&#123;sec:section<span class="built_in">_</span>with<span class="built_in">_</span>short<span class="built_in">_</span>title&#125; is a section with a short title. <span class="comment">%交叉引用</span></span><br><span class="line">	<span class="keyword">\section</span>*&#123;&#125;</span><br><span class="line">	<span class="keyword">\subsection</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">\subsection</span>*&#123;&#125;</span><br><span class="line">	<span class="keyword">\subsubsection</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">\subsubsection</span>*&#123;&#125;</span><br><span class="line">	<span class="keyword">\paragraph</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">\par</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h1><h2 id="常用数学符号"><a href="#常用数学符号" class="headerlink" title="常用数学符号"></a>常用数学符号</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\because</td>
<td style="text-align:center">$\because$</td>
<td style="text-align:center">\therefore</td>
<td style="text-align:center">$\therefore$</td>
</tr>
<tr>
<td style="text-align:center">\frac{a}{b}</td>
<td style="text-align:center">$\frac{a}{b}$</td>
<td style="text-align:center">\dfrac{a}{b}</td>
<td style="text-align:center">$\dfrac{a}{b}$</td>
</tr>
<tr>
<td style="text-align:center">\cdot</td>
<td style="text-align:center">$\cdot$</td>
<td style="text-align:center">\cdots</td>
<td style="text-align:center">$\cdots$</td>
</tr>
<tr>
<td style="text-align:center">\ldots</td>
<td style="text-align:center">$\ldots$</td>
<td style="text-align:center">\infty</td>
<td style="text-align:center">$\infty$</td>
</tr>
<tr>
<td style="text-align:center">\log</td>
<td style="text-align:center">$\log$</td>
<td style="text-align:center">\lim</td>
<td style="text-align:center">$\lim$</td>
</tr>
<tr>
<td style="text-align:center">\sin</td>
<td style="text-align:center">$\sin$</td>
<td style="text-align:center">\cos</td>
<td style="text-align:center">$\cos$</td>
</tr>
<tr>
<td style="text-align:center">\rightarrow</td>
<td style="text-align:center">$\rightarrow$</td>
<td style="text-align:center">\int_{0}^{1}</td>
<td style="text-align:center">$\int_{0}^{1}$</td>
</tr>
<tr>
<td style="text-align:center">\iint</td>
<td style="text-align:center">$\iint$</td>
<td style="text-align:center">\oint</td>
<td style="text-align:center">$\oint$</td>
</tr>
<tr>
<td style="text-align:center">\oiint</td>
<td style="text-align:center">$\oiint$</td>
<td style="text-align:center">\iiint</td>
<td style="text-align:center">$\iiint$</td>
</tr>
</tbody>
</table>
</div>
<p>\sum\limits_{i=1}^{10}:  $\sum\limits_{i=1}^{10}$ </p>
<p>\prod\limits_{i=1}^{10}: $\prod\limits_{i=1}^{10}$</p>
<p>\lim\limits_{i\rightarrow+\infty}: $\lim\limits_{i\rightarrow+\infty}$</p>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\alpha</td>
<td style="text-align:center">$\alpha$</td>
<td style="text-align:center">\varepsilon</td>
<td style="text-align:center">$\varepsilon$</td>
</tr>
<tr>
<td style="text-align:center">\delta</td>
<td style="text-align:center">$\delta$</td>
<td style="text-align:center">\pi</td>
<td style="text-align:center">$\pi$</td>
</tr>
<tr>
<td style="text-align:center">\rho</td>
<td style="text-align:center">$\rho$</td>
<td style="text-align:center">\lambda</td>
<td style="text-align:center">$\lambda$</td>
</tr>
<tr>
<td style="text-align:center">\varphi</td>
<td style="text-align:center">$\varphi$</td>
<td style="text-align:center">\mu</td>
<td style="text-align:center">$\mu$</td>
</tr>
<tr>
<td style="text-align:center">\Delta</td>
<td style="text-align:center">$\Delta$</td>
<td style="text-align:center">\Sigma</td>
<td style="text-align:center">$\Sigma$</td>
</tr>
<tr>
<td style="text-align:center">\Pi</td>
<td style="text-align:center">$\Pi$</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\equiv</td>
<td style="text-align:center">$\equiv$</td>
<td style="text-align:center">\neq</td>
<td style="text-align:center">$\neq$</td>
</tr>
<tr>
<td style="text-align:center">\leqslant</td>
<td style="text-align:center">$\leqslant$</td>
<td style="text-align:center">\geqslant</td>
<td style="text-align:center">$\geqslant$</td>
</tr>
<tr>
<td style="text-align:center">\sim</td>
<td style="text-align:center">$\sim$</td>
<td style="text-align:center">\approx</td>
<td style="text-align:center">$\approx$</td>
</tr>
<tr>
<td style="text-align:center">\mid</td>
<td style="text-align:center">$\mid$</td>
<td style="text-align:center">\nmid</td>
<td style="text-align:center">$\nmid$</td>
</tr>
<tr>
<td style="text-align:center">\pm</td>
<td style="text-align:center">$\pm$</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h2><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\left( \right)</td>
<td style="text-align:center">$\left(\right)$</td>
<td style="text-align:center">\left[ \right]</td>
<td style="text-align:center">$\left[\right]$</td>
</tr>
<tr>
<td style="text-align:center">\left\\{ \right\\}</td>
<td style="text-align:center">$\left\{\right\}$</td>
<td style="text-align:center">\left\lbrace \right\rbrace</td>
<td style="text-align:center">$\left\lbrace\right\rbrace$</td>
</tr>
<tr>
<td style="text-align:center">\left&lt; \right&gt;</td>
<td style="text-align:center">$\left&lt;\right&gt;$</td>
<td style="text-align:center">\left) \right(</td>
<td style="text-align:center">$\left) \right($</td>
</tr>
<tr>
<td style="text-align:center">\left&#124; \right&#124;</td>
<td style="text-align:center">$\left&#124;\right&#124;$</td>
<td style="text-align:center">\left\\&#124; \right\\\&#124;</td>
<td style="text-align:center">$\left\&#124; \right\&#124;$</td>
</tr>
<tr>
<td style="text-align:center">\left\{ \right.</td>
<td style="text-align:center">$\left\{ \right.$</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;subfigure&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;caption2&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\figurename</span>&#125;&#123;图&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\captionlabeldelim</span>&#125;&#123;.&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\thesubfigure</span>&#125; &#123;<span class="keyword">\thefigure</span>.<span class="keyword">\arabic</span>&#123;subfigure&#125;&#125; <span class="keyword">\makeatletter</span></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\@thesubfigure</span>&#125;&#123;<span class="keyword">\thesubfigure</span>:<span class="keyword">\space</span>&#125; <span class="keyword">\renewcommand</span>&#123;<span class="keyword">\p@subfigure</span>&#125;&#123;&#125; <span class="keyword">\makeatother</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;figure&#125;[h]</span><br><span class="line">		<span class="keyword">\centering</span></span><br><span class="line">		<span class="keyword">\includegraphics</span>[width=0.8<span class="keyword">\textwidth</span>]&#123;filepath/pngname.png&#125;</span><br><span class="line">		<span class="keyword">\caption</span>&#123;caption of this figure&#125;</span><br><span class="line">		<span class="keyword">\label</span>&#123;label of this figure&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;figure&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;figure&#125;[H]</span><br><span class="line">		<span class="keyword">\centering</span></span><br><span class="line">		<span class="keyword">\subfigure</span>[caption of this subfigure-1]&#123;</span><br><span class="line">			<span class="keyword">\includegraphics</span>[width=0.45<span class="keyword">\textwidth</span>]&#123;filepath/pngname&#125;</span><br><span class="line">			<span class="keyword">\label</span>&#123;label of this subfigure-1&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">\subfigure</span>[caption of this subfigure-2]&#123;</span><br><span class="line">			<span class="keyword">\includegraphics</span>[width=0.45<span class="keyword">\textwidth</span>]&#123;filepath/pngname&#125;</span><br><span class="line">			<span class="keyword">\label</span>&#123;label of this subfigure-2&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">\caption</span>&#123;caption of figures&#125;</span><br><span class="line">		<span class="keyword">\label</span>&#123;label of figures&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;figure&#125;</span><br><span class="line">	use <span class="keyword">\ref</span>&#123;label of this figure&#125; to quote it. <span class="comment">%交叉引用</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;listings&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;xcolor&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\setmonofont</span>&#123;Consolas&#125;</span><br><span class="line"><span class="keyword">\setsansfont</span>&#123;Consolas&#125;</span><br><span class="line"><span class="keyword">\lstset</span>&#123;</span><br><span class="line">	columns=fixed,</span><br><span class="line">	breakatwhitespace=true,</span><br><span class="line">	breaklines=true,</span><br><span class="line">	breakindent=26pt,</span><br><span class="line">	captionpos=bl,</span><br><span class="line">	numbers=left,</span><br><span class="line">	frame=shadowbox,</span><br><span class="line">	basicstyle=<span class="keyword">\ttfamily</span>,</span><br><span class="line">	keywordstyle=<span class="keyword">\ttfamily</span><span class="keyword">\color</span>&#123;blue&#125;,</span><br><span class="line">	numberstyle=<span class="keyword">\footnotesize</span><span class="keyword">\color</span>&#123;darkgray&#125;,</span><br><span class="line">	commentstyle=<span class="keyword">\ttfamily</span><span class="keyword">\it</span><span class="keyword">\color</span>[RGB]&#123;0,96,96&#125;,</span><br><span class="line">	stringstyle=<span class="keyword">\ttfamily</span><span class="keyword">\color</span>&#123;magenta&#125;,</span><br><span class="line">	showstringspaces=false,</span><br><span class="line">	language=Java,</span><br><span class="line">	identifierstyle=<span class="keyword">\ttfamily</span>,</span><br><span class="line">	tabsize=4,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;lstlisting&#125;[title=&#123;<span class="keyword">\bf</span> your.title&#125;]</span><br><span class="line"><span class="comment">% put your code here</span></span><br><span class="line">	<span class="keyword">\end</span>&#123;lstlisting&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h1 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h1><p>闲得无聊查了一下，惊奇地发现Latex甚至可以画图，而且功能极其庞大，甚至有老哥画了个印度地图。。。</p>
<p><a href="https://texample.net/tikz/examples/">https://texample.net/tikz/examples/</a></p>
<p>找到个网站。要用的时候到里面找吧。</p>
]]></content>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>fabric学习1-架构</title>
    <url>/2020/12/08/fabric%E5%AD%A6%E4%B9%A01-%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>先学习一下架构部分</p>
<a id="more"></a>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>Fabric是一个许可区块链的分布式操作系统，可以执行多种编程语言编写的分布式应用。它能够在一个只能追加的数据结构中安全地跟踪执行历史，并且没有内置的加密账本。</p>
<p>Fabric使用了“执行-order-验证”的区块链架构，而没有遵顼标准的“order-执行”设计。其整体的分布式应用可以分为两个部分</p>
<ul>
<li><p>智能合约，称为链码 (<em>Chaincode</em>) ，是一段实现了应用逻辑的程序代码，并在执行过程中运行。链码是Fabric分布式应用的核心部分，可能会被未受信任的开发者修改。有一种特殊的链码被用于管理区块链系统并维护参数，被称为系统链码 (<em>system chaincode</em>) </p>
</li>
<li><p>背书政策 (<em>endorsement policy</em>) 在验证阶段进行评价。许可政策无法被未受信任的开发者选择或修改。其在区块链中充当一个用于事物验证的静态库，且只能通过链码进行参数化。只有指定的管理员有权限使用系统管理功能修改。</p>
</li>
</ul>
<p>“执行-排序-验证”结构示意图：</p>
<p><img data-src="execute-order-validate.png" alt=""></p>
<p>一个客户端向背书政策指定的peer节点(peers)发送交易。这个交易被特殊的peer节点执行并且记录输出信息，这一步骤被称为背书。执行完成后，交易进入了排序(ordering)阶段，在这一个阶段中，使用了一种可插入的共识协议来产生一个完成排序的已背书交易的序列，并按区块分组。这些交易被广播到所有的节点。这个序列的顺序由输出和状态的依赖性决定。在验证阶段，每个peer节点都需要根据背书政策和执行的一致性对已背书交易的状态变化进行验证。所有peer节点都已相同的顺序进行验证，因此结果具有确定性。</p>
<p>Fabric网络支持多个区块链链接到同一个排序服务上。每个区块链被称为一个通道(<em>Channel</em>)，可以有不同的peer节点作为其成员。这些通道可以被用来分离不同的区块链之间的状态，但每个通道的共识并不一致，并且通道中的交易顺序是相互分开的。认为所有排序都是可信的部署，可以通过通道访问控制来实现对节点的控制。</p>
<p>其中的节点可分为：客户端、peer节点（其中一部分为背书节点）、排序服务节点(OSN, <em>Ordering Service Nodes</em> or <em>orderers</em>)</p>
<h2 id="交易的三个阶段"><a href="#交易的三个阶段" class="headerlink" title="交易的三个阶段"></a>交易的三个阶段</h2><p><img data-src="transaction_flow.png" alt="transaction_flow"></p>
<h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>在执行阶段，客户端签署并发送一个交易提案给一个或多个背书节点来执行（根据背书政策，每个chaincode都有特定的一组背书节点）。一个交易提案包含了提交客户端的身份（根据MSP），交易的载荷、参数、链码标识符、每个客户端只能使用一次的nonce（随机值或计数器），以及客户端标识符和nonce生成的交易标识符。</p>
<p>背书节点会对交易提案进行模拟，在指定的区块链链码上执行操作。模拟操作在背书节点的本地区块链状态中进行模拟，不与其它节点同步，也不会将模拟的结果永久化到帐本中。区块链的状态仍然由节点交易管理器(<em>Peer Transaction Manager</em>)维护。一个链码创建的状态只能限定在该链码上，不能被其他的链码直接访问。需要注意的是，链码只能维护GetState、PutState、DelState操作访问的内容（<em>可能意思是：需要使用这些接口进行访问，不能直接修改，猜测状态权限为private</em>）。给予适当的权限，链码可以调用同一个通道的链码，并访问其状态。</p>
<p>在模拟后，背书节点会产生一个<em>writeset</em>，其中包括模拟产生的状态更新，和一个<em>readset</em>，代表交易提案模拟的版本依赖（模拟时的所有密钥以及对应的版本号）。在模拟结束后，背书节点会以加密的方式签署一份“背书”消息，包括了<em>writeset</em>和<em>readset</em>（包括交易id和背书节点的一些数据），随后以响应的方式发送给客户端。客户端收集背书，直到满足链码的背书政策，开始交易。特别的，这要求政策决定的所有背书节点都返回相同的<em>writeset</em>和<em>readset</em>。然后，客户端将继续创建交易，并传递给排序阶段。</p>
<h3 id="排序阶段"><a href="#排序阶段" class="headerlink" title="排序阶段"></a>排序阶段</h3><p>客户端收集到足够的背书后，将会把交易组装起来并发送给排序服务端。整个交易包括了载荷(<em>payload</em>)（包括参数的链码操作）、交易元数据、背书的集合。排序阶段对每个通道的所有提交建立了一个排序。排序服务端会将多个交易分成块，输出包含交易的哈希链序列，以提高广播协议的吞吐量。</p>
<ul>
<li><code>broadcast(tx)</code>：客户端调用这个函数来广播交易<code>tx</code>，包含了载荷和签名。</li>
<li><code>B$$\leftarrow$$deliver(s)</code>：客户端调用这个函数来获取非负序列号<code>s</code>的区块<code>B</code>，$B=([tx_1,tx_2,\ldots,tx_k],h)$，$h$为<code>s-1</code>区块的哈希值。</li>
</ul>
<p>排序服务确保了一个通道中的交付区块被完全排序，确保安全。</p>
<p>然而，每一个单独的排序实现都允许在客户端请求中保证自己的活跃性与公平性。</p>
<p>由于区块链中包含了大量的节点，但仅有少部分节点实现了排序服务，因此Fabric可以配置使用内置的gossip服务，将排序服务中交付的区块分发给所有的节点。</p>
<h3 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h3><p>排序服务会把区块直接分发给各个节点（或通过<em>gossip</em>）。随后，一个新的区块进入验证阶段，包含三个连续步骤：</p>
<ul>
<li>并行执行区块中所有的交易的背书政策评估。评估是验证系统链码(VSCC, <em>validation system chaincode</em>)的任务。VSCC是一个静态库，是区块链配置的一部分，负责根据链码中的背书政策验证背书。如果不满足，这个交易会被标记为无效，并被忽略。</li>
<li>对块中的所有交易进行读写冲突检查(<em>read-write conflict check</em>)（版本号比较）。对于每个交易，将会对比其中readset的版本号和节点本地存储的账本当前状态中的版本号，确保版本相同。如果版本不匹配，交易会被标记为无效，并被忽略。</li>
<li>最后进行账本的更新阶段，在这个阶段，区块被追加到本地存储的账本中，并且更新区块链的状态。将区块添加到账本时，前两步的检查结果将被持久化以掩码的形式表示区块中的交易有效。这有助于后面进行重建状态。此外，所有的状态更新都是通过将<em>writeset</em>中的键值对写入本地完成的。</li>
</ul>
<h2 id="信任与故障模型"><a href="#信任与故障模型" class="headerlink" title="信任与故障模型"></a>信任与故障模型</h2><p>Fabric可以适应灵活的信任和故障假设。通常情况下，所有的客户端都被认为是潜在的恶意用户或是<em>Byzantine</em>。节点都被归入组织(<em>organization</em>)并且每个组织组成一个信任域(<em>trust domain</em>)。每个节点信任其组织内部的其他节点，而不信任其他组织的节点。排序服务同样认为所有的节点（或客户端）都是潜在的拜占庭。</p>
<p>Fabric网络的完整性依赖于排序服务的一致性。排序服务的信任模型取决于其实现。</p>
<p>在Fabric中，分布式应用可以定义自己的信任假设，通过背书政策来传达，并且独立于排序服务实现的共识的信任假设。</p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>Fabric使用了gRPC架构实现客户端、节点和排序服务之间的通信。</p>
<h2 id="成员身份管理服务（MSP）"><a href="#成员身份管理服务（MSP）" class="headerlink" title="成员身份管理服务（MSP）"></a>成员身份管理服务（MSP）</h2><p>成员身份管理服务(MSP, <em>membership service provider</em>)维护了系统中所有节点（客户端、节点、排序服务）的身分，并负责发布节点的凭证，用于认证和授权。节点之间的所有交互都是通过已认证的消息（通常是数字签名）发生的。成员身份管理包括每个节点的组件，可以认证交易、验证交易的完整性、签署并确认背书、验证其他的区块链操作。MSP中还包括了用于密钥管理和节点注册的工具。</p>
<p>MSP是抽象的，可以有不同的实例。Fabric中，默认的MSP实现可以处理基于数字签名的PKI认证方法，并且容纳商业认证机构(CA)。Fabric提供了独立的CA——Fabric-CA。</p>
<p>Fabric允许设置区块链网络的两种模式。在离线模式下，凭证由CA生成，并分发到所有节点。peer节点和排序节点只能在离线模式下注册。对于客户端的注册，Fabric-CA提供了在线模式，向客户端发送加密凭证。MSP的配置必须要确保所有的节点都能识别相同的身份和认证认定为有效（特别是所有的peer节点）。</p>
<p>例如，当多个组织在同一个区块链网络中时，MSP需要能够允许身份的联合。每个组织向自己的成员发放身份，每个peer节点都能识别所有组织的成员。这可以通过多个MSP实例来实现。例如，在每个组织和一个MSP之间建立一个映射。</p>
<h2 id="排序服务"><a href="#排序服务" class="headerlink" title="排序服务"></a>排序服务</h2><p>排序服务可管理多个通道，对每个通道，都提供如下三个服务：</p>
<ol>
<li><em>Atomic broadcast</em>，用于对交易进行排序，实现广播和分发</li>
<li>重新配置(<em>reconfiguration</em>)通道，成员通过广播一个配置更新事物(<em>configuration update transaction</em>)修改通道。</li>
<li>（可选择）访问控制(<em>access control</em>)，在这些配置中，排序服务作为可信的实体，限制交易的广播和指定peer节点和客户端的块的接收</li>
</ol>
<p>排序服务通过系统通道上的生成块进行引导。生成块携带了配置事务(<em>configuration transaction</em>)，定义了排序服务的操作。</p>
<p>当前版本的实现由OSN组成，OSN实现了描述的操作并且通过系统通道通信。实际的<em>atomic broadcast</em>函数由基于<em>ZooKeeper</em>的Kafka实例提供，这个实例提供了可以扩展的发布-订阅消息，在节点崩溃后仍具有强一致性(<em>consistency</em>)。这个实现可以运行在与OSN分离的物理节点上。OSN作为peers和Kafka实例之间的代理。</p>
<p>OSN直接将收到的新交易注入到广播中。OSN将从广播中接收到的交易转换成块。只要满足三个情况之一，块就会被断开。</p>
<ul>
<li>区块包含了交易允许的最大值</li>
<li>区块达到最大大小</li>
<li>从接收到第一个交易后超过某特定时间</li>
</ul>
<p>批处理的过程是确定的，因此在所有节点上都会产生相同的区块。考虑到从广播中接收的交易数据流，前两项情况是已经确定的。对于第三个条件，当节点读入块中的第一个交易时，会开启一个计时器。如果计时器超时后，这个区块仍然没有断开，OSN会在通道上广播一个特殊的“到时断开(<em>time-to-cut</em>)”交易，其中记录了需要断开的区块的序列号。另一方面，每个OSN在收到“到时断开”交易后，会根据其给定的序列号，立即切断新的区块。这个交易是原子性的分发给所有连接的OSN，所以区块中都包含相同的交易列表。OSN将最近交付的一系列区块直接持久化到文件系统中，因此可以通过分发回答peer节点来回收区块。</p>
]]></content>
      <tags>
        <tag>crypto</tag>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/11/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>基物实验</title>
    <url>/2020/11/17/%E5%9F%BA%E7%89%A9%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>记录一下自己做实验时的各种坑与总结的经验，以后可以提醒提醒学弟。</p>
<a id="more"></a>
<h1 id="分光仪"><a href="#分光仪" class="headerlink" title="分光仪"></a>分光仪</h1><p>实验时间：2020年9月21日</p>
<p>这是我做的第一个实验，成功AK（手动狗头）</p>
<h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2><p>第一步的粗调非常重要，决定了你接下来的调整速度。个人经验是在实验前千万不要去玩那些螺丝，也许上个人已经调好了，上来随便调一调就合格，可以直接做实验。</p>
<p>按照正常的方法去调整就行，遇到的唯一困难就是转180°后找不到绿十字了，这时可以考虑先用眼睛去找，确定了绿十字反射回来的位置之后再去调目镜和平台，后面按照视频里或者老师讲的做就可以，应该没什么难度。</p>
<h2 id="测量三棱镜的顶角"><a href="#测量三棱镜的顶角" class="headerlink" title="测量三棱镜的顶角"></a>测量三棱镜的顶角</h2><p>这个实验还是挺水的。。。随便测测就行了。顶角是60°，测量结果应该是120°</p>
<h2 id="最小偏向角法测量棱镜的折射率"><a href="#最小偏向角法测量棱镜的折射率" class="headerlink" title="最小偏向角法测量棱镜的折射率"></a>最小偏向角法测量棱镜的折射率</h2><p>这个实验最大的坑就是“最小偏向角”一定要旋转三棱镜的摆放位置，直到折射光的偏转最小。（折射光在右手边就让光尽可能靠左，左手边就尽可能靠右）</p>
<p>后面应该就不需要去动三棱镜了，钠光的入射光应该是可以找到的。</p>
<p>最终的测量结果应该在50°50′左右。</p>
<h2 id="掠入射法测量棱镜的折射率"><a href="#掠入射法测量棱镜的折射率" class="headerlink" title="掠入射法测量棱镜的折射率"></a>掠入射法测量棱镜的折射率</h2><p>当时做这个实验的时候主要是不知道怎么摆放。。。好在最后找了个做过的大佬，画了个草图。</p>
<p><img data-src="掠入射测量棱镜的折射率.jpg" alt=""></p>
<p>最终的测量结果应该在39°左右。</p>
<p>如果时间不够用的话，一个省时间的技巧是在测下一组数据的时候不动目镜，只转动刻度盘，这样就可以少调整一次。（如果彻底没有时间了，那就测量一组，然后写到第五组的位置上，剩下的数据全靠编。我室友就这么硬水过的。。。）</p>
<h2 id="干涉法测平板玻璃折射率"><a href="#干涉法测平板玻璃折射率" class="headerlink" title="干涉法测平板玻璃折射率"></a>干涉法测平板玻璃折射率</h2><p>这个实验做了也不算积分，而且至少要1小时的时间，所以就没做（也没人做）。</p>
<h1 id="示波器"><a href="#示波器" class="headerlink" title="示波器"></a>示波器</h1><p>实验时间：2020年10月26日</p>
<p>做的第一个非光学实验（绪论除外），没能AK，后面就决定重回光学的怀抱了。</p>
<h2 id="示波器的使用"><a href="#示波器的使用" class="headerlink" title="示波器的使用"></a>示波器的使用</h2><p>这个还是挺简单的，但建议速度一定要快，给后面两个实验留点时间。</p>
<p>需要注意的是，这个实验老师是会查现象的，所以最好不要尝试去水。其实水的目的不是混分，都是现象做出来了，只是时间不够时的一个手段而已，非常不建议滥用，毕竟做出实验现象还是很爽的。</p>
<h2 id="二极管伏安特性曲线"><a href="#二极管伏安特性曲线" class="headerlink" title="二极管伏安特性曲线"></a>二极管伏安特性曲线</h2><p>当时按照电路图连了电路，结果发现线貌似不够用，打算先测量声速。</p>
<p>然后就没有然后了</p>
<h2 id="声速测量"><a href="#声速测量" class="headerlink" title="声速测量"></a>声速测量</h2><p>测量声速的时候遇到了好几个坑。</p>
<ol>
<li>实验前和实验后一定要记得调整频率，使得振幅最大，并记录下来。</li>
<li>实验的线材和器材有毒，各种连接不稳定，最后是用笔袋支撑着线才能做实验的。</li>
<li>我当时老师要求振幅法和李萨如法都要用，很耽误时间，建议先做第二个实验。不过我当时的老师人比较好，让我们几个人拖延了一会，硬是把数据记完了，而且没有查实验器材。</li>
</ol>
<h1 id="迈克尔逊干涉"><a href="#迈克尔逊干涉" class="headerlink" title="迈克尔逊干涉"></a>迈克尔逊干涉</h1><p>实验时间：2020年11月9日</p>
<p>第二个光学实验，也AK了。让人不禁感叹，光学实验真的是适合刷积分啊。</p>
<h2 id="迈克尔逊干涉-1"><a href="#迈克尔逊干涉-1" class="headerlink" title="迈克尔逊干涉"></a>迈克尔逊干涉</h2><p>这个实验老师会讲好久（但里面有不少干货，建议认真听），我当时足足讲了1小时20分钟，讲到最后我都直接开激光偷偷调整了。</p>
<p>整个调整步骤有四步，一步一步来就行，别忘了第一步是调激光入射光就行（我做完实验才发现这个事情，还好最后没出现问题）。如果发现自己找不到水平一排的三个亮点，可能是入射光没有完全射到各个镜子上，调整的时候出现问题了还是动脑子想一想吧，毕竟遇到的问题真的是各种各样的都有。</p>
<p>如果发现迈克尔逊环很密的话，可能是反射镜位置不太对，调整到老师推荐的位置，然后拧一拧应该就能出来。</p>
<p>装置的空程差真的让人绝望，我一开始大概转了60圈才消除掉，</p>
<p>数的时候真的可能会数错。。。建议十个十个数。技巧就是一定要数内缩环，外扩真的纠结应该数到哪里。</p>
<h2 id="牛顿环干涉"><a href="#牛顿环干涉" class="headerlink" title="牛顿环干涉"></a>牛顿环干涉</h2><p>感觉牛顿环是最简单的实验了，只需要调好反射镜的位置和目镜的高度就行。重点是不要数错环，我当时是从11数到20。。。建议从6数到15。</p>
<p>数错了重新数其实也浪费不了多少时间，如果懒的话就继续编数据大法吧。。。</p>
<h2 id="劈尖干涉"><a href="#劈尖干涉" class="headerlink" title="劈尖干涉"></a>劈尖干涉</h2><p>这个实验的劈尖干涉应该是来得及做的，我当时最后有几十分钟的时间来纠结应该怎么做（其实想法一直都没问题，但我的仪器测量范围有问题，浪费了巨量时间）。当时认识的大佬没做这个实验，于是只能自己摸索了。下面是我总结的实验步骤。</p>
<ol>
<li><p>本实验的样本无须自己制作。</p>
</li>
<li><p>做实验过程中遇到的唯一障碍在于测量“细丝位置到尖端的距离”。我遇到的样本为一张纸，因此与图片中的细丝有些小差别。实际操作中的装置如下图所示（左侧是尖端，右侧的小横线是纸张）。图片中的L就是需要测量的部分。具体做法大致就是把装置侧过来，显微镜对焦，然后从尖端量到纸张即可。</p>
<p><img data-src="劈尖装置示意图.jpg" alt=""></p>
</li>
<li><p>我用的仪器貌似有问题。。。小于25mm的部分手轮转不过去，最后还是借室友的仪器做的……</p>
</li>
<li><p>在测量干涉条纹宽度时，显微镜物镜可能会被螺丝卡住，建议把装置倒过来测量，把四个突出来的螺丝放在下面当支柱。。。</p>
</li>
<li><p>我的测量结果是$L\approx39\ \mathrm{mm}$, $n=5$时$l\approx5.6\ \mathrm{mm}$。反正最后处理时别忘了还有个$n$就行，刚开始算出来的结果给我人都看傻了，最后算的大概是$50\mu m$，感觉小了一些，不过至少还有点靠谱。</p>
</li>
</ol>
<h1 id="钠光干涉"><a href="#钠光干涉" class="headerlink" title="钠光干涉"></a>钠光干涉</h1><p>时间：2020年11月16日</p>
<p>第三个光学实验，第一个非必修实验。</p>
<p>这次没有AK（这句话导致我险些被室友暴打）。还是大意了，没有闪。</p>
<h2 id="钠光双棱镜"><a href="#钠光双棱镜" class="headerlink" title="钠光双棱镜"></a>钠光双棱镜</h2><p>本实验的仪器调整步骤很坑，耽误了巨量时间。。。最后只能卡点强行搞完双棱镜的实验。</p>
<p>我最后总结的调整方法：</p>
<ol>
<li>前面用ppt或者书上的方法都行，毕竟各个元器件的高度之类的还是比较好调的。</li>
<li>到最后找大小像和干涉条纹时，一定要先找干涉条纹，老师也强调了，但没说怎么操作。。。搞得我各种前后移动最后还是找不到。最后发现是双棱镜和狭缝不平行所导致的。</li>
<li>最好的方法是先参考别人的报告摆放好狭缝和双棱镜的位置（这样可以确保有20个条纹），让目镜紧贴双棱镜，旋转双棱镜或调整狭缝宽度以找到清晰的干涉条纹，再把目镜拉到正确的位置，找大小像并把叉丝调到中心。</li>
<li>实验室的双棱镜上半部分是空的，会漏光。所以如果发现目镜拉远后干涉条纹被光盖住了，可以试试把双棱镜位置提高一点。</li>
</ol>
<p>另外，感觉目镜手轮的4和5很容易读错，读的时候一定要注意一点。仪器的位置最好和已有实验报告的位置差不多，可以对着别人的数据检查，不然最后数据偏差过大就傻了。这种东西能水过去就尽量水过去吧。。。</p>
<h2 id="钠光劳埃镜"><a href="#钠光劳埃镜" class="headerlink" title="钠光劳埃镜"></a>钠光劳埃镜</h2><p>勉强做完双棱镜，gg。祝xdm好运。</p>
<h1 id="稳态法测不良导体热导率"><a href="#稳态法测不良导体热导率" class="headerlink" title="稳态法测不良导体热导率"></a>稳态法测不良导体热导率</h1><p>时间：2020年12月5日</p>
<p>第一个热学实验，英文实验+研究性实验</p>
<p>热学实验就离谱。把装置调好之后等着就行了，建议带个作业去写，或者把器材的数据简单处理一下。大概得等1个多小时吧，加热盘温度到达75℃之后再等散热盘温度稳定就行了。实际操作的时候不一定非要到75℃，毕竟示数会有误差，加到74.9℃之后发现一直没变化就可以记录了。（试验台在过道边上是真的坑，走来走去的对实验结果真的有影响）</p>
<p>英文实验熟悉了老师的口语之后还是可以听懂的。我当时的老师人很好，和他说了想做研究性实验之后说可以让我们待到下午上课前，后来直接让我们去没人的实验台做实验了。</p>
<p>我做的研究性实验就是做了个无风扇的实验，然后两个实验进行对比，结论是有风扇实验系统误差高，无风扇实验偶然误差高，并为实验在风扇上提出了两个改进方案。做研究性实验的话建议去知网找找，我就是在知网找到一篇比较风扇的论文，然后自己做实验，实验原理找了个物竞大佬教。</p>
<p>（感觉上课和老师聊研究性实验的时候，全班同学都在用一种怪异的眼神看着我…）</p>
<h1 id="绪论实验"><a href="#绪论实验" class="headerlink" title="绪论实验"></a>绪论实验</h1><p>实验时间：2020年10月12日</p>
<p>绪论实验没什么好说的，就是上来会有个小测验，建议稍微准备一下。我那次雨课堂测试，十几个人平均分3.8/10，就nm离谱。</p>
<p>绪论的报告要求会略高一点点，既要列出公式也要把数值带进去的式子写上，最后再写答案。计算步骤直接上知乎抄吧。</p>
<p>听说最后的给分都挺低，4分就算不错了。也不知道是不是真的。</p>
]]></content>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>not RSA WriteUp</title>
    <url>/2020/12/09/not-RSA-WriteUp/</url>
    <content><![CDATA[<p>题目来源：安恒四月赛（DASCTF 2020）</p>
<a id="more"></a>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> AITMCLab.libnum <span class="keyword">import</span> gcd, invmod, s2n</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> isPrime</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line">p = <span class="number">104879397075344024438671231239628115011303349344697797964879592144922079000957</span> </span><br><span class="line">q = <span class="number">104879397075344024438671231239628115011303349344697797964879592144922079001013</span></span><br><span class="line"><span class="keyword">assert</span> isPrime(p) <span class="keyword">and</span> isPrime(q)</span><br><span class="line">n = p * q</span><br><span class="line">flag = s2n(flag)</span><br><span class="line">r = randint(<span class="number">1</span>, n)</span><br><span class="line">c = (<span class="built_in">pow</span>(n + <span class="number">1</span>, flag, n * n) * <span class="built_in">pow</span>(r, n, n * n)) % (n * n)</span><br><span class="line"><span class="built_in">print</span> c</span><br><span class="line"><span class="comment"># c = 13134489820394613222282607681686272081419875146946401883172682167011759113388373349180457979897848113275982219264879081189886853062717764580364698888338032141434053832247476010400449272010082460437747190468766740274587999336359171283098137261396013153130265440425676242061845667887640808895666325466803989428</span></span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>代码很简单，就是道纯数学题</p>
<p>由源码：</p>
<p>$c\equiv (n+1)^f\cdot r^n\ (\mathrm{mod}\ n^2)$</p>
<p>根据二项式定理：</p>
<p>$c\equiv (fn+1)\cdot r^n\ (mod\ n^2)$</p>
<p>左右两式同乘$\varphi(n)$次方，得$c^{\varphi(n)}\equiv (fn+1)^{\varphi(n)}\cdot r^{n\varphi(n)}\ (mod\ n^2)$</p>
<p>由$\varphi(n^2)=n\cdot \varphi(n)$且当$r\neq p$或$r\neq q$时有，$gcd(r,n)=1$可知，$r^{n\varphi(n)}\equiv 1\ (mod\ n^2)$，可得：</p>
<p>$c^{\varphi(n)}\equiv (fn+1)^{\varphi(n)}\ (mod\ n^2)$</p>
<p>因为r为随机数，所以$r\neq p,q$的概率为$\dfrac{2}{n}$，可认为$gcd(r,n)=1$成立。</p>
<p>再次使用二次项定理，可得$c^{\varphi(n)}\equiv fn\varphi(n)+1\ (mod\ n^2)$</p>
<p>由费曼小定理可知$c^{\varphi(n)}\equiv 1\ (mod\ n)$，即$n|c^{\varphi(n)}-1$，因此将1移到同余式左边并对同余式同除n，得：</p>
<p>$\dfrac{c^{\varphi(n)}-1}{n}\equiv f\varphi(n)\ (mod\ n)$</p>
<p>对于左式，设$\dfrac{c^{\varphi(n)}-1}{n}=kn+r’$</p>
<p>$c^{\varphi(n)}=kn^2+rn+1$</p>
<p>只需求解出$rn+1$即可，因此可以对$c^{\varphi(n)}$进行模$n^2$，实现时可直接使用python中的pow函数。</p>
<p>将左式求解后，化为求解$\varphi(n)\cdot f\equiv r’\ (mod\ n)$，即$f\equiv \varphi(n)^{-1}\cdot r’\ (mod\ n)$</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> AITMCLab.libnum <span class="keyword">import</span> s2n, invmod, n2s</span><br><span class="line"></span><br><span class="line">c = <span class="number">131344898203946132222826076816862720814198751469464018831726821670</span> <span class="number">117591133883733491804579798978481132759822192648790811898868530627</span> <span class="number">177645803646988883380321414340538322474760104004492720100824604377</span> <span class="number">471904687667402745879993363591712830981372613960131531302654404256</span> <span class="number">76242061845667887640808895666325466803989428</span></span><br><span class="line">p = <span class="number">104879397075344024438671231239628115011303349344697797964879592144</span> <span class="number">922079000957</span> </span><br><span class="line">q = <span class="number">104879397075344024438671231239628115011303349344697797964879592144</span> <span class="number">922079001013</span></span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">n = p * q</span><br><span class="line">r = (<span class="built_in">pow</span>(c, phi_n, n * n) - <span class="number">1</span>) // n</span><br><span class="line"><span class="built_in">print</span> n2s(r * invmod(phi_n, n) % n)</span><br></pre></td></tr></table></figure>
<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>flag\{can_you_find_me??\}</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>纯数学题</p>
<p>学长带着推了一遍。。。这也太难了。。。</p>
<p>听说是<em>paillier</em>加密，果然不是RSA</p>
]]></content>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>BabyRSA WriteUp</title>
    <url>/2020/12/09/BabyRSA-WriteUp/</url>
    <content><![CDATA[<p>题目来源：N1CTF 2019</p>
<a id="more"></a>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line">N = <span class="number">23981306327188221819291352455300124608114670714977979223022816906368788909398653961976023086718129607035805397846230124785550919468973090809881210560931396002918119995710297723411794214888622784232065592366390586879306041418300835178522354945438521139847806375923379136235993890801176301812907708937658277646761892297209069757559519399120988948212988924583632878840216559421398253025960456164998680766732013248599742397199862820924441357624187811402515396393385081892966284318521068948266144251848088067639941653475035145362236917008153460707675427945577597137822575880268720238301307972813226576071488632898694390629</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">m = number.bytes_to_long(flag)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;flag.enc&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> m:</span><br><span class="line">        padding = random.randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">1000</span>) ** <span class="number">2</span></span><br><span class="line">        message = padding &lt;&lt; <span class="number">1</span> + m % <span class="number">2</span></span><br><span class="line">        cipher = <span class="built_in">pow</span>(message, e, N)</span><br><span class="line">        f.write(<span class="built_in">hex</span>(cipher)+<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">        m /= <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先阅读代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> m:</span><br><span class="line">    <span class="comment"># several operations</span></span><br><span class="line">    m /= <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>由上述代码部分以及过程中出现了<code>m % 2</code>操作可知，flag的二进制数据每一位被存进了<code>key.enc</code>文件的每行数据中，因此对<code>key.enc</code>文件的每一行进行读取，只要能够判断该位为0还是1，即可完成解密。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">padding = random.randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">1000</span>) ** <span class="number">2</span></span><br><span class="line">message = padding &lt;&lt; <span class="built_in">pow</span>(m, p - <span class="number">1</span>, p) + m % <span class="number">2</span></span><br><span class="line">cipher = <span class="built_in">pow</span>(message, e, N)</span><br></pre></td></tr></table></figure>
<p>由上述代码可知，$c\equiv m^e\ (\mathrm{mod}\ N), m = r^2\cdot 2^{1+flag\%2}$ （r为random结果），因此<code>m%2=1</code>时，有$c\equiv r^2\cdot 2^2\equiv (2^er^e)^2\ (\mathrm{mod}\ N)$，而<code>m%2=0</code>时，有$c\equiv 2^e\cdot r^{2^e}$。</p>
<p>首先猜测可以通过破解RSA密码，将加密信息还原为明文信息，判断该数整除2的奇数次方还是偶数次方即可得知该位的二进制数。使用factordb网站失败后贼心不死，又尝试了网上找的多种攻击脚本，发现均无法分解，于是寻找其它方法。</p>
<p>观察<del>README.md</del>发现，本题可以尝试用二次剩余求解。<code>m%2=1</code>时，有$c\equiv (2^er^e)^2\ (\mathrm{mod}\ N)$，<code>m%2=0</code>时，有$c\equiv (2\cdot r^2)^e\ (\mathrm{mod}\ N)$，因此，当c为N的二次剩余时，对应<code>m%2=1</code>，c为N的二次非剩余时，对应<code>m%2=0</code>。</p>
<p>可以使用Jacobi判断是否为二次剩余。只需满足$\left(\dfrac{2^e\cdot r^{2^e}}{N}\right)=-1$即可求解。由于$\left(\dfrac{2^e\cdot r^{2^e}}{N}\right)=\left(\dfrac{2}{p}\right)\left(\dfrac{2}{q}\right)$，所以当<code>m%2=0</code>时，Jacobi计算结果仅取决于p和q，且在实际计算中发现存在Jacobi计算结果为-1的情况，又因为<code>m%2=1</code>时Jacobi计算结果必然为1，说明本题中2分别是p和q的二次剩余和二次非剩余，可得下式</p>
<script type="math/tex; mode=display">
\left(\dfrac{c}{N}\right)= \begin{cases}\left(\dfrac{2}{p}\right)\left(\dfrac{2}{q}\right)=-1,m\%2=0\\1, m\%2=1\end{cases}</script><p>因此可以用Jacobi来计算flag的二进制结果。</p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jacobi</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>) ** ((b * b - <span class="number">1</span>) / <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">if</span> a == b - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>) ** ((b - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        res *= jacobi(<span class="number">2</span>, b)</span><br><span class="line">        a /= <span class="number">2</span></span><br><span class="line">    res *= (<span class="number">-1</span>)**((a - <span class="number">1</span>) * (b - <span class="number">1</span>) / <span class="number">4</span>) * jacobi(b % a, a)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">n = <span class="number">21950613536281390486175757463951027643556662621824579929664918617520636813458994325720569579695736856079459340474316751889021883755540017377473409564797843019125596929359598746535191841338208989879009508321774759757392464348925062704618198548398309908878380041795632951630513476281083426748653263731919122841901104123145297521411331174923397782111024006706017326210374498919922250769088886696170966869394222786903527353128540253585182758832324462426318387914150570168191590734053846371944717431858873198597415498765665035309188308408227521317670668417094970551798085092238594309838065757300622761550073415879726501051</span></span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;key.enc&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        line = line.strip(<span class="string">&quot;L\n&quot;</span>)    <span class="comment"># Filter out &quot;L\n&quot; at the end of line</span></span><br><span class="line">        cur = <span class="built_in">int</span>(line, <span class="number">16</span>)         <span class="comment"># Convert hax string to number</span></span><br><span class="line">        <span class="keyword">if</span> (jacobi(cur, n) == <span class="number">1</span>):</span><br><span class="line">            flag += <span class="number">1</span> &lt;&lt; i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span> flag</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> flag</span><br><span class="line"><span class="built_in">print</span> long_to_bytes(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先从<code>key.enc</code>中逐行读取，并对每一行结尾的’L\n’进行过滤，将其转换为整数cur后，计算Jacobi符号$J\left( cur, N\right)$。计算Jacobi符号时主要使用二次互反律进行计算（可以再使用其它定律进行加速，但没必要）。</p>
<p>由于第一行储存的为flag的最后一位（即从后往前储存），因此进行<code>flag += 1 &lt;&lt; i</code>即可将相应位置的二进制结果还原。</p>
<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>N1CTF\{You_can_leak_the_jacobi_symbol_from_RSA\}</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题在代码阅读上难度较低，唯一需要留意的地方就是<code>padding &lt;&lt; pow(m, p - 1, p) + m % 2</code>这个运算的优先级问题（感谢bg的注释提示）。把代码转换成数学公式后，二次剩余的方法就比较明显了，需要注意的是<code>Jacobi</code>符号无法准确判断二次剩余与二次非剩余（感谢bg指出了这个问题），简单推导后发现这个方法有一定的使用条件，如果题目中的p和q不满足一定的条件，这个方法就无法正确区分0和1。</p>
<hr>
<p>后经大佬提醒发现这道题用的是Goldwasser-Micali密码（上课走神实锤了）。简单对比发现，当GM密码选取的x满足<code>J(x, p) = 1</code>且<code>J(x, q) = -1</code>时，可能能够利用本题的方法进行破解。因此选取的x不能仅满足是n的二次非剩余，需要同时是p和q的二次非剩余。</p>
]]></content>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
</search>
