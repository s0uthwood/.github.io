<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>First Crypto</title>
    <url>/2020/11/15/First-Crypto/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间学习信安数基，助教学长就配套出了道Quiz，来给我们练手。这两天决定记录一下学习过程，就拿来来给博客练手（手动狗头）。</p>
<a id="more"></a>
<p><del>一个大四的老同志，来，出题，来，欺负，我们大二的小学弟，这好吗？这不好。还好我是有备而来</del></p>
<p>废话说到这里，先上题目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> getRandomNBitInteger</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> getPrime</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> isPrime</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> inverse</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPrime</span>(<span class="params">n</span>):</span></span><br><span class="line">    n += <span class="number">2</span> <span class="keyword">if</span> n &amp; <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> isPrime(n):</span><br><span class="line">        n += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>(<span class="params">S, K</span>):</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    k = []</span><br><span class="line">    K = <span class="built_in">list</span>(K)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(K)):</span><br><span class="line">        K[i] = <span class="built_in">ord</span>(K[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        S.append(i)</span><br><span class="line">        k.append(K[i % <span class="built_in">len</span>(K)])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + S[i] + k[i]) % <span class="number">256</span></span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Encrypt</span>(<span class="params">key, D</span>):</span></span><br><span class="line">    S=[]</span><br><span class="line">    init(S, key)</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> D:</span><br><span class="line">        a = <span class="built_in">ord</span>(a)</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + S[i]) % <span class="number">256</span></span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line">        k = <span class="built_in">chr</span>(a ^ S[(S[i] + S[j]) % <span class="number">256</span>])</span><br><span class="line">        result += k</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Decrypt</span>(<span class="params">key, D</span>):</span></span><br><span class="line">    S = []</span><br><span class="line">    init(S, key)</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> D:</span><br><span class="line">        a = <span class="built_in">ord</span>(a)</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + S[i]) % <span class="number">256</span></span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line">        k = <span class="built_in">chr</span>(a ^ S[(S[i] + S[j]) % <span class="number">256</span>])</span><br><span class="line">        result += k</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    key = long_to_bytes(getRandomNBitInteger(<span class="number">100</span>))</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;key =&#x27;</span>, bytes_to_long(key)</span><br><span class="line">    e = getPrime(<span class="number">512</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;e =&#x27;</span>, e</span><br><span class="line"></span><br><span class="line">    E = nextPrime(e)</span><br><span class="line">    f = math.factorial(e) % E</span><br><span class="line"></span><br><span class="line">    d = long_to_bytes(f)</span><br><span class="line"></span><br><span class="line">    c1 = bytes_to_long(Encrypt(key, d))</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;c1 =&#x27;</span>, c1</span><br><span class="line"></span><br><span class="line">    c2 = bytes_to_long(Encrypt(key, flag))</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;c2 =&#x27;</span>, c2</span><br><span class="line"></span><br><span class="line"><span class="comment"># e = 11248112333656902878308992204660514716130692202019193081806766887380465145401754698746718075268681481388695805324253817155823465013590321091178897918430457</span></span><br><span class="line"><span class="comment"># c1 = 11792816667683654209610238149228683194178884298019505853565076663183883681365400495420305428570416004628438524072440231323696408946395141935772862600031614</span></span><br><span class="line"><span class="comment"># c2 = 81946333492800053045881242964212560642046177081574600318494251620269838444004879162713842</span></span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先阅读主函数部分，显然这道题需要先通过e, E求解f，以此得到d，随后再利用d, c1, c2来求解flag。</p>
<h2 id="求解f"><a href="#求解f" class="headerlink" title="求解f"></a>求解f</h2><p>题目中的$f=e!\mathrm{mod} E$ ，但由于e过大，显然无法直接计算得到。观察发现，$e!$ 当中的绝大多数部分可以两两配对组成模$E$的逆元，因此猜测可能存在类似于$(E-1)!\equiv 1\ (\mathrm{mod}\ E)$ 的规律，如果满足这个规律，我们就可以通过计算$\prod\limits_{i=e+1}^{E-1}i\ (\mathrm{mod}\ E)$ 的逆元得到f。</p>
<p>经过几次简单的检验，猜测规律为$(E-2)!\equiv 1\ (\mathrm{mod}\ E)$ （后得知为Wilson定理，当时还没学…），因此只需要计算$tmp\equiv \prod\limits_{i=e+1}^{E-2}i\ (\mathrm{mod}\ E),\ f\cdot tmp\equiv 1\ (\mathrm{mod}\ E)$ 即可得到$f$。</p>
<h2 id="求解flag"><a href="#求解flag" class="headerlink" title="求解flag"></a>求解flag</h2><p>得到了 f 后，可以直接利用<code>long_to_bytes(f)</code>来得到 d 。为求解 flag，初步设想为利用加密函数求解 key，随后直接利用解密函数求解 flag。阅读<code>Encrypt</code>函数和<code>Decrypt</code>函数后发现加解密函数完全一致，且实际的加解密过程只有异或运算，说明 d 到 c1 的运算步骤与 flag 到 c2 的运算步骤完全相同且可逆，因此求解时没必要求出 key。进一步分析后发现加密算法大致是将 key 转化成某个固定的数组，并与明文依次进行异或运算得到密文，也就是说经过了 init 函数和多次交换位置（交换的次序也是固定的）后的数列才是真正的密钥。</p>
<p>因此，只需要将 c1, c2 和 d 转换成 bytes，然后对每一位取 <code>ord</code> 后进行异或运算，组成的数字取 <code>chr</code> 后加到答案字符串后面，即可得到 flag。</p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> AITMCLab.libnum.modular <span class="keyword">import</span> invmod</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> isPrime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPrime</span>(<span class="params">n</span>):</span></span><br><span class="line">    n += <span class="number">2</span> <span class="keyword">if</span> n &amp; <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> isPrime(n):</span><br><span class="line">        n += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    e = <span class="number">11248112333656902878308992204660514716130692202019193081806766887380465145401754698746718075268681481388695805324253817155823465013590321091178897918430457</span></span><br><span class="line">    c1 = <span class="number">5120829596353532760839054347975234579355835073413768618360492980516438193909447500996222328143719619379838946544412967584025416378147246422705451415437468</span></span><br><span class="line">    c2 = <span class="number">17985907282297772406857113433926323639543183645704827789984971602150950301590677893419082</span></span><br><span class="line">    E = nextPrime(e)</span><br><span class="line">    f_1 = <span class="number">1</span></span><br><span class="line">    i = e + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; E - <span class="number">1</span>:</span><br><span class="line">        f_1 *= i</span><br><span class="line">        f_1 %= E</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    f = invmod(f_1, E)</span><br><span class="line">    <span class="comment"># 以上为求解f的过程</span></span><br><span class="line">    d = long_to_bytes(f)</span><br><span class="line">    c1_bytes = long_to_bytes(c1)</span><br><span class="line">    c2_bytes = lone_to_bytes(c2)</span><br><span class="line">    flag = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c2_bytes)):</span><br><span class="line">        flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(c2_bytes[i]) ^ <span class="built_in">ord</span>(c1_bytes[i]) ^ <span class="built_in">ord</span>(d[i]))</span><br><span class="line">    <span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure>
<h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>flag{Congratulation!_quiz1_passed!!!}</p>
]]></content>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>My Latex Cheatsheet</title>
    <url>/2020/11/15/My-Latex-Cheatsheet/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>整理一下自己用过的latex命令。</p>
<p><del>先占个坑，还没想好怎么写…</del></p>
<p>现在想好怎么写了，慢慢填坑吧。。。</p>
<a id="more"></a>
<h1 id="标题及基础设置"><a href="#标题及基础设置" class="headerlink" title="标题及基础设置"></a>标题及基础设置</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[a4paper, zihao=-4, UTF8]&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\CTEXsetup</span>[format=&#123;<span class="keyword">\Large</span><span class="keyword">\bfseries</span>&#125;]&#123;section&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\pagesytle</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%\setcounter&#123;section&#125;&#123;-1&#125;   % section start from 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">	<span class="keyword">\maketitle</span></span><br><span class="line">	<span class="keyword">\section</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">\section</span>[short title]&#123;&#125;</span><br><span class="line">	<span class="keyword">\label</span>&#123;sec:section<span class="built_in">_</span>with<span class="built_in">_</span>short<span class="built_in">_</span>title&#125;</span><br><span class="line">	section <span class="keyword">\ref</span>&#123;sec:section<span class="built_in">_</span>with<span class="built_in">_</span>short<span class="built_in">_</span>title&#125; is a section with a short title. <span class="comment">%交叉引用</span></span><br><span class="line">	<span class="keyword">\section</span>*&#123;&#125;</span><br><span class="line">	<span class="keyword">\subsection</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">\subsection</span>*&#123;&#125;</span><br><span class="line">	<span class="keyword">\subsubsection</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">\subsubsection</span>*&#123;&#125;</span><br><span class="line">	<span class="keyword">\paragraph</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">\par</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h1><h2 id="常用数学符号"><a href="#常用数学符号" class="headerlink" title="常用数学符号"></a>常用数学符号</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\because</td>
<td style="text-align:center">$\because$</td>
<td style="text-align:center">\therefore</td>
<td style="text-align:center">$\therefore$</td>
</tr>
<tr>
<td style="text-align:center">\frac{a}{b}</td>
<td style="text-align:center">$\frac{a}{b}$</td>
<td style="text-align:center">\dfrac{a}{b}</td>
<td style="text-align:center">$\dfrac{a}{b}$</td>
</tr>
<tr>
<td style="text-align:center">\cdot</td>
<td style="text-align:center">$\cdot$</td>
<td style="text-align:center">\cdots</td>
<td style="text-align:center">$\cdots$</td>
</tr>
<tr>
<td style="text-align:center">\ldots</td>
<td style="text-align:center">$\ldots$</td>
<td style="text-align:center">\infty</td>
<td style="text-align:center">$\infty$</td>
</tr>
<tr>
<td style="text-align:center">\log</td>
<td style="text-align:center">$\log$</td>
<td style="text-align:center">\lim</td>
<td style="text-align:center">$\lim$</td>
</tr>
<tr>
<td style="text-align:center">\sin</td>
<td style="text-align:center">$\sin$</td>
<td style="text-align:center">\cos</td>
<td style="text-align:center">$\cos$</td>
</tr>
<tr>
<td style="text-align:center">\rightarrow</td>
<td style="text-align:center">$\rightarrow$</td>
<td style="text-align:center">\int_{0}^{1}</td>
<td style="text-align:center">$\int_{0}^{1}$</td>
</tr>
<tr>
<td style="text-align:center">\iint</td>
<td style="text-align:center">$\iint$</td>
<td style="text-align:center">\oint</td>
<td style="text-align:center">$\oint$</td>
</tr>
<tr>
<td style="text-align:center">\oiint</td>
<td style="text-align:center">$\oiint$</td>
<td style="text-align:center">\iiint</td>
<td style="text-align:center">$\iiint$</td>
</tr>
<tr>
<td style="text-align:center">\in</td>
<td style="text-align:center">$\in$</td>
<td style="text-align:center">\notin</td>
<td style="text-align:center">$\notin$</td>
</tr>
<tr>
<td style="text-align:center">\forall</td>
<td style="text-align:center">$\forall$</td>
<td style="text-align:center">\exist</td>
<td style="text-align:center">$\exist$</td>
</tr>
<tr>
<td style="text-align:center">\sqrt{a}</td>
<td style="text-align:center">$\sqrt{a}$</td>
<td style="text-align:center">\exist</td>
<td style="text-align:center">$\exist$</td>
</tr>
</tbody>
</table>
</div>
<p>\sum\limits_{i=1}^{10}:  $\sum\limits_{i=1}^{10}$ </p>
<p>\prod\limits_{i=1}^{10}: $\prod\limits_{i=1}^{10}$</p>
<p>\lim\limits_{i\rightarrow+\infty}: $\lim\limits_{i\rightarrow+\infty}$</p>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\alpha</td>
<td style="text-align:center">$\alpha$</td>
<td style="text-align:center">\varepsilon</td>
<td style="text-align:center">$\varepsilon$</td>
</tr>
<tr>
<td style="text-align:center">\delta</td>
<td style="text-align:center">$\delta$</td>
<td style="text-align:center">\pi</td>
<td style="text-align:center">$\pi$</td>
</tr>
<tr>
<td style="text-align:center">\rho</td>
<td style="text-align:center">$\rho$</td>
<td style="text-align:center">\lambda</td>
<td style="text-align:center">$\lambda$</td>
</tr>
<tr>
<td style="text-align:center">\varphi</td>
<td style="text-align:center">$\varphi$</td>
<td style="text-align:center">\mu</td>
<td style="text-align:center">$\mu$</td>
</tr>
<tr>
<td style="text-align:center">\Delta</td>
<td style="text-align:center">$\Delta$</td>
<td style="text-align:center">\Sigma</td>
<td style="text-align:center">$\Sigma$</td>
</tr>
<tr>
<td style="text-align:center">\Pi</td>
<td style="text-align:center">$\Pi$</td>
<td style="text-align:center">\theta</td>
<td style="text-align:center">$\theta$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\equiv</td>
<td style="text-align:center">$\equiv$</td>
<td style="text-align:center">\neq</td>
<td style="text-align:center">$\neq$</td>
</tr>
<tr>
<td style="text-align:center">\leqslant</td>
<td style="text-align:center">$\leqslant$</td>
<td style="text-align:center">\geqslant</td>
<td style="text-align:center">$\geqslant$</td>
</tr>
<tr>
<td style="text-align:center">\sim</td>
<td style="text-align:center">$\sim$</td>
<td style="text-align:center">\approx</td>
<td style="text-align:center">$\approx$</td>
</tr>
<tr>
<td style="text-align:center">\mid</td>
<td style="text-align:center">$\mid$</td>
<td style="text-align:center">\nmid</td>
<td style="text-align:center">$\nmid$</td>
</tr>
<tr>
<td style="text-align:center">\pm</td>
<td style="text-align:center">$\pm$</td>
<td style="text-align:center">\times</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">\cup</td>
<td style="text-align:center">$\cup$</td>
<td style="text-align:center">\cap</td>
<td style="text-align:center">$\cap$</td>
</tr>
<tr>
<td style="text-align:center">\subset</td>
<td style="text-align:center">$\subset$</td>
<td style="text-align:center">\supset</td>
<td style="text-align:center">$\supset$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
<th style="text-align:center">Code</th>
<th style="text-align:center">Latex</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\left( \right)</td>
<td style="text-align:center">$\left(\right)$</td>
<td style="text-align:center">\left[ \right]</td>
<td style="text-align:center">$\left[\right]$</td>
</tr>
<tr>
<td style="text-align:center">\left\\{ \right\\}</td>
<td style="text-align:center">$\left\{\right\}$</td>
<td style="text-align:center">\left\lbrace \right\rbrace</td>
<td style="text-align:center">$\left\lbrace\right\rbrace$</td>
</tr>
<tr>
<td style="text-align:center">\left&lt; \right&gt;</td>
<td style="text-align:center">$\left&lt;\right&gt;$</td>
<td style="text-align:center">\left) \right(</td>
<td style="text-align:center">$\left) \right($</td>
</tr>
<tr>
<td style="text-align:center">\left&#124; \right&#124;</td>
<td style="text-align:center">$\left&#124;\right&#124;$</td>
<td style="text-align:center">\left\\&#124; \right\\\&#124;</td>
<td style="text-align:center">$\left\&#124; \right\&#124;$</td>
</tr>
<tr>
<td style="text-align:center">\left\{ \right.</td>
<td style="text-align:center">$\left\{ \right.$</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;subfigure&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;caption2&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\figurename</span>&#125;&#123;图&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\captionlabeldelim</span>&#125;&#123;.&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\thesubfigure</span>&#125; &#123;<span class="keyword">\thefigure</span>.<span class="keyword">\arabic</span>&#123;subfigure&#125;&#125; <span class="keyword">\makeatletter</span></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\@thesubfigure</span>&#125;&#123;<span class="keyword">\thesubfigure</span>:<span class="keyword">\space</span>&#125; <span class="keyword">\renewcommand</span>&#123;<span class="keyword">\p@subfigure</span>&#125;&#123;&#125; <span class="keyword">\makeatother</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;figure&#125;[h]</span><br><span class="line">		<span class="keyword">\centering</span></span><br><span class="line">		<span class="keyword">\includegraphics</span>[width=0.8<span class="keyword">\textwidth</span>]&#123;filepath/pngname.png&#125;</span><br><span class="line">		<span class="keyword">\caption</span>&#123;caption of this figure&#125;</span><br><span class="line">		<span class="keyword">\label</span>&#123;label of this figure&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;figure&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;figure&#125;[H]</span><br><span class="line">		<span class="keyword">\centering</span></span><br><span class="line">		<span class="keyword">\subfigure</span>[caption of this subfigure-1]&#123;</span><br><span class="line">			<span class="keyword">\includegraphics</span>[width=0.45<span class="keyword">\textwidth</span>]&#123;filepath/pngname&#125;</span><br><span class="line">			<span class="keyword">\label</span>&#123;label of this subfigure-1&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">\subfigure</span>[caption of this subfigure-2]&#123;</span><br><span class="line">			<span class="keyword">\includegraphics</span>[width=0.45<span class="keyword">\textwidth</span>]&#123;filepath/pngname&#125;</span><br><span class="line">			<span class="keyword">\label</span>&#123;label of this subfigure-2&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">\caption</span>&#123;caption of figures&#125;</span><br><span class="line">		<span class="keyword">\label</span>&#123;label of figures&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;figure&#125;</span><br><span class="line">	use <span class="keyword">\ref</span>&#123;label of this figure&#125; to quote it. <span class="comment">%交叉引用</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;listings&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;xcolor&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\setmonofont</span>&#123;Consolas&#125;</span><br><span class="line"><span class="keyword">\setsansfont</span>&#123;Consolas&#125;</span><br><span class="line"><span class="keyword">\lstset</span>&#123;</span><br><span class="line">	columns=fixed,</span><br><span class="line">	breakatwhitespace=true,</span><br><span class="line">	breaklines=true,</span><br><span class="line">	breakindent=26pt,</span><br><span class="line">	captionpos=bl,</span><br><span class="line">	numbers=left,</span><br><span class="line">	frame=shadowbox,</span><br><span class="line">	basicstyle=<span class="keyword">\ttfamily</span>,</span><br><span class="line">	keywordstyle=<span class="keyword">\ttfamily</span><span class="keyword">\color</span>&#123;blue&#125;,</span><br><span class="line">	numberstyle=<span class="keyword">\footnotesize</span><span class="keyword">\color</span>&#123;darkgray&#125;,</span><br><span class="line">	commentstyle=<span class="keyword">\ttfamily</span><span class="keyword">\it</span><span class="keyword">\color</span>[RGB]&#123;0,96,96&#125;,</span><br><span class="line">	stringstyle=<span class="keyword">\ttfamily</span><span class="keyword">\color</span>&#123;magenta&#125;,</span><br><span class="line">	showstringspaces=false,</span><br><span class="line">	language=Java,</span><br><span class="line">	identifierstyle=<span class="keyword">\ttfamily</span>,</span><br><span class="line">	tabsize=4,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;lstlisting&#125;[title=&#123;<span class="keyword">\bf</span> your.title&#125;]</span><br><span class="line"><span class="comment">% put your code here</span></span><br><span class="line">	<span class="keyword">\end</span>&#123;lstlisting&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;authblk&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span>*&#123;<span class="keyword">\Affilfont</span>&#125;&#123;<span class="keyword">\small</span>&#125; <span class="comment">% 修改机构名称的字体与大小</span></span><br><span class="line"><span class="keyword">\renewcommand</span><span class="keyword">\Authand</span>&#123;, &#125; <span class="comment">% 去掉 and 前的逗号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;<span class="keyword">\textbf</span>&#123;Title&#125; &#125;</span><br><span class="line"><span class="keyword">\author</span>[1]&#123;xxx&#125;</span><br><span class="line"><span class="keyword">\author</span>[2]&#123;xxx&#125;</span><br><span class="line"><span class="keyword">\affil</span>[1]&#123;(<span class="keyword">\it</span> 北京xx大学<span class="keyword">\ </span>xx学院,<span class="keyword">\ </span><span class="keyword">\rm</span> 0000)&#125;</span><br><span class="line"><span class="keyword">\affil</span>[2]&#123;(<span class="keyword">\it</span> 北京xx大学<span class="keyword">\ </span>xx学院,<span class="keyword">\ </span><span class="keyword">\rm</span> 0000)&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>中英文摘要</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\enabstractname</span>&#125;&#123;Abstract&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\cnabstractname</span>&#125;&#123;摘要&#125;</span><br><span class="line"><span class="keyword">\newenvironment</span>&#123;cnabstract&#125;&#123;<span class="comment">%</span></span><br><span class="line">	<span class="keyword">\par</span><span class="keyword">\small</span></span><br><span class="line">	<span class="keyword">\noindent</span><span class="keyword">\mbox</span>&#123;&#125;<span class="keyword">\hfill</span>&#123;<span class="keyword">\bfseries</span> <span class="keyword">\cnabstractname</span>&#125;<span class="keyword">\hfill</span><span class="keyword">\mbox</span>&#123;&#125;<span class="keyword">\par</span></span><br><span class="line">	<span class="keyword">\vskip</span> 2.5ex&#125;&#123;<span class="keyword">\par</span><span class="keyword">\vskip</span> 2.5ex&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\newenvironment</span>&#123;enabstract&#125;&#123;<span class="comment">%</span></span><br><span class="line">	<span class="keyword">\par</span><span class="keyword">\small</span></span><br><span class="line">	<span class="keyword">\noindent</span><span class="keyword">\mbox</span>&#123;&#125;<span class="keyword">\hfill</span>&#123;<span class="keyword">\bfseries</span> <span class="keyword">\enabstractname</span>&#125;<span class="keyword">\hfill</span><span class="keyword">\mbox</span>&#123;&#125;<span class="keyword">\par</span></span><br><span class="line">	<span class="keyword">\vskip</span> 1.5ex&#125;&#123;<span class="keyword">\par</span><span class="keyword">\vskip</span> 2.5ex&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;cnabstract&#125;</span><br><span class="line">		xxx</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">\textbf</span>&#123;关键词：&#125;xxx;xxx;xxx</span><br><span class="line">	<span class="keyword">\end</span>&#123;cnabstract&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;enabstract&#125;</span><br><span class="line">		xxx</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">\textbf</span>&#123;Keywords:&#125;xxx;xxx;xxx;</span><br><span class="line">	<span class="keyword">\end</span>&#123;enabstract&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h1 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;hyperref&#125;</span><br><span class="line"><span class="keyword">\hypersetup</span>&#123;</span><br><span class="line">	colorlinks=true,</span><br><span class="line">	citecolor=blue,</span><br><span class="line">	linkcolor=blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">	<span class="keyword">\ref</span>&#123;label&#125;</span><br><span class="line">	<span class="keyword">\nameref</span>&#123;label&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">\cite</span>&#123;1&#125; <span class="comment">% cite a reference</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">\begin</span>&#123;thebibliography&#125;&#123;99&#125; <span class="comment">% reference</span></span><br><span class="line">		<span class="keyword">\bibitem</span>&#123;1&#125;</span><br><span class="line">		xxx,xxx,xxx</span><br><span class="line">	<span class="keyword">\end</span>&#123;thebibliography&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;appendix&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\appendixname</span>&#125;&#123;Appendix~<span class="keyword">\Alph</span>&#123;section&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">	<span class="keyword">\newpage</span></span><br><span class="line">	<span class="keyword">\appendix</span></span><br><span class="line">	<span class="keyword">\section</span>&#123;xxxxx&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h1 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h1><p>闲得无聊查了一下，惊奇地发现Latex甚至可以画图，而且功能极其庞大，甚至有老哥画了个印度地图。。。</p>
<p><a href="https://texample.net/tikz/examples/">https://texample.net/tikz/examples/</a></p>
<p>找到个网站。要用的时候到里面找吧。</p>
]]></content>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>fabric学习1-架构</title>
    <url>/2020/12/08/fabric%E5%AD%A6%E4%B9%A01-%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>参考文献：<a href="/download/1801.10228.pdf">Hyperledger Fabric: A Distributed Operation System for Permissioned Blockchains</a></p>
<a id="more"></a>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>Fabric是一个许可区块链的分布式操作系统，可以执行多种编程语言编写的分布式应用。它能够在一个只能追加的数据结构中安全地跟踪执行历史，并且没有内置的加密账本。</p>
<p>Fabric使用了“执行-order-验证”的区块链架构，而没有遵顼标准的“order-执行”设计。其整体的分布式应用可以分为两个部分</p>
<ul>
<li><p>智能合约，称为链码 (<em>Chaincode</em>) ，是一段实现了应用逻辑的程序代码，并在执行过程中运行。链码是Fabric分布式应用的核心部分，可能会被未受信任的开发者修改。有一种特殊的链码被用于管理区块链系统并维护参数，被称为系统链码 (<em>system chaincode</em>) </p>
</li>
<li><p>背书政策 (<em>endorsement policy</em>) 在验证阶段进行评价。许可政策无法被未受信任的开发者选择或修改。其在区块链中充当一个用于事物验证的静态库，且只能通过链码进行参数化。只有指定的管理员有权限使用系统管理功能修改。</p>
</li>
</ul>
<p>“执行-排序-验证”结构示意图：</p>
<p><img data-src="execute-order-validate.png" alt=""></p>
<p>一个客户端向背书政策指定的peer节点(peers)发送交易。这个交易被特殊的peer节点执行并且记录输出信息，这一步骤被称为背书。执行完成后，交易进入了排序(ordering)阶段，在这一个阶段中，使用了一种可插入的共识协议来产生一个完成排序的已背书交易的序列，并按区块分组。这些交易被广播到所有的节点。这个序列的顺序由输出和状态的依赖性决定。在验证阶段，每个peer节点都需要根据背书政策和执行的一致性对已背书交易的状态变化进行验证。所有peer节点都已相同的顺序进行验证，因此结果具有确定性。</p>
<p>Fabric网络支持多个区块链链接到同一个排序服务上。每个区块链被称为一个通道(<em>Channel</em>)，可以有不同的peer节点作为其成员。这些通道可以被用来分离不同的区块链之间的状态，但每个通道的共识并不一致，并且通道中的交易顺序是相互分开的。认为所有排序都是可信的部署，可以通过通道访问控制来实现对节点的控制。</p>
<p>其中的节点可分为：客户端、peer节点（其中一部分为背书节点）、排序服务节点(OSN, <em>Ordering Service Nodes</em> or <em>orderers</em>)</p>
<h2 id="交易的三个阶段"><a href="#交易的三个阶段" class="headerlink" title="交易的三个阶段"></a>交易的三个阶段</h2><p><img data-src="transaction_flow.png" alt="transaction_flow"></p>
<h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>在执行阶段，客户端签署并发送一个交易提案给一个或多个背书节点来执行（根据背书政策，每个chaincode都有特定的一组背书节点）。一个交易提案包含了提交客户端的身份（根据MSP），交易的载荷、参数、链码标识符、每个客户端只能使用一次的nonce（随机值或计数器），以及客户端标识符和nonce生成的交易标识符。</p>
<p>背书节点会对交易提案进行模拟，在指定的区块链链码上执行操作。模拟操作在背书节点的本地区块链状态中进行模拟，不与其它节点同步，也不会将模拟的结果永久化到帐本中。区块链的状态仍然由节点交易管理器(<em>Peer Transaction Manager</em>)维护。一个链码创建的状态只能限定在该链码上，不能被其他的链码直接访问。需要注意的是，链码只能维护GetState、PutState、DelState操作访问的内容（<em>可能意思是：需要使用这些接口进行访问，不能直接修改，猜测状态权限为private</em>）。给予适当的权限，链码可以调用同一个通道的链码，并访问其状态。</p>
<p>在模拟后，背书节点会产生一个<em>writeset</em>，其中包括模拟产生的状态更新，和一个<em>readset</em>，代表交易提案模拟的版本依赖（模拟时的所有密钥以及对应的版本号）。在模拟结束后，背书节点会以加密的方式签署一份“背书”消息，包括了<em>writeset</em>和<em>readset</em>（包括交易id和背书节点的一些数据），随后以响应的方式发送给客户端。客户端收集背书，直到满足链码的背书政策，开始交易。特别的，这要求政策决定的所有背书节点都返回相同的<em>writeset</em>和<em>readset</em>。然后，客户端将继续创建交易，并传递给排序阶段。</p>
<h3 id="排序阶段"><a href="#排序阶段" class="headerlink" title="排序阶段"></a>排序阶段</h3><p>客户端收集到足够的背书后，将会把交易组装起来并发送给排序服务端。整个交易包括了载荷(<em>payload</em>)（包括参数的链码操作）、交易元数据、背书的集合。排序阶段对每个通道的所有提交建立了一个排序。排序服务端会将多个交易分成块，输出包含交易的哈希链序列，以提高广播协议的吞吐量。</p>
<ul>
<li><code>broadcast(tx)</code>：客户端调用这个函数来广播交易<code>tx</code>，包含了载荷和签名。</li>
<li><code>B</code> $\leftarrow$ <code>deliver(s)</code>：客户端调用这个函数来获取非负序列号<code>s</code>的区块<code>B</code>，$B=([tx_1,tx_2,\ldots,tx_k],h)$，$h$为<code>s-1</code>区块的哈希值。</li>
</ul>
<p>排序服务确保了一个通道中的交付区块被完全排序，确保安全。</p>
<p>然而，每一个单独的排序实现都允许在客户端请求中保证自己的活跃性与公平性。</p>
<p>由于区块链中包含了大量的节点，但仅有少部分节点实现了排序服务，因此Fabric可以配置使用内置的gossip服务，将排序服务中交付的区块分发给所有的节点。</p>
<h3 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h3><p>排序服务会把区块直接分发给各个节点（或通过<em>gossip</em>）。随后，一个新的区块进入验证阶段，包含三个连续步骤：</p>
<ul>
<li>并行执行区块中所有的交易的背书政策评估。评估是验证系统链码(VSCC, <em>validation system chaincode</em>)的任务。VSCC是一个静态库，是区块链配置的一部分，负责根据链码中的背书政策验证背书。如果不满足，这个交易会被标记为无效，并被忽略。</li>
<li>对块中的所有交易进行读写冲突检查(<em>read-write conflict check</em>)（版本号比较）。对于每个交易，将会对比其中readset的版本号和节点本地存储的账本当前状态中的版本号，确保版本相同。如果版本不匹配，交易会被标记为无效，并被忽略。</li>
<li>最后进行账本的更新阶段，在这个阶段，区块被追加到本地存储的账本中，并且更新区块链的状态。将区块添加到账本时，前两步的检查结果将被持久化以掩码的形式表示区块中的交易有效。这有助于后面进行重建状态。此外，所有的状态更新都是通过将<em>writeset</em>中的键值对写入本地完成的。</li>
</ul>
<h2 id="信任与故障模型"><a href="#信任与故障模型" class="headerlink" title="信任与故障模型"></a>信任与故障模型</h2><p>Fabric可以适应灵活的信任和故障假设。通常情况下，所有的客户端都被认为是潜在的恶意用户或是<em>Byzantine</em>。节点都被归入组织(<em>organization</em>)并且每个组织组成一个信任域(<em>trust domain</em>)。每个节点信任其组织内部的其他节点，而不信任其他组织的节点。排序服务同样认为所有的节点（或客户端）都是潜在的拜占庭。</p>
<p>Fabric网络的完整性依赖于排序服务的一致性。排序服务的信任模型取决于其实现。</p>
<p>在Fabric中，分布式应用可以定义自己的信任假设，通过背书政策来传达，并且独立于排序服务实现的共识的信任假设。</p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>Fabric使用了gRPC架构实现客户端、节点和排序服务之间的通信。</p>
<h2 id="成员身份管理服务（MSP）"><a href="#成员身份管理服务（MSP）" class="headerlink" title="成员身份管理服务（MSP）"></a>成员身份管理服务（MSP）</h2><p>成员身份管理服务(MSP, <em>membership service provider</em>)维护了系统中所有节点（客户端、节点、排序服务）的身分，并负责发布节点的凭证，用于认证和授权。节点之间的所有交互都是通过已认证的消息（通常是数字签名）发生的。成员身份管理包括每个节点的组件，可以认证交易、验证交易的完整性、签署并确认背书、验证其他的区块链操作。MSP中还包括了用于密钥管理和节点注册的工具。</p>
<p>MSP是抽象的，可以有不同的实例。Fabric中，默认的MSP实现可以处理基于数字签名的PKI认证方法，并且容纳商业认证机构(CA)。Fabric提供了独立的CA——Fabric-CA。</p>
<p>Fabric允许设置区块链网络的两种模式。在离线模式下，凭证由CA生成，并分发到所有节点。peer节点和排序节点只能在离线模式下注册。对于客户端的注册，Fabric-CA提供了在线模式，向客户端发送加密凭证。MSP的配置必须要确保所有的节点都能识别相同的身份和认证认定为有效（特别是所有的peer节点）。</p>
<p>例如，当多个组织在同一个区块链网络中时，MSP需要能够允许身份的联合。每个组织向自己的成员发放身份，每个peer节点都能识别所有组织的成员。这可以通过多个MSP实例来实现。例如，在每个组织和一个MSP之间建立一个映射。</p>
<h2 id="排序服务"><a href="#排序服务" class="headerlink" title="排序服务"></a>排序服务</h2><p>排序服务可管理多个通道，对每个通道，都提供如下三个服务：</p>
<ol>
<li><em>Atomic broadcast</em>，用于对交易进行排序，实现广播和分发</li>
<li>重新配置(<em>reconfiguration</em>)通道，成员通过广播一个配置更新事物(<em>configuration update transaction</em>)修改通道。</li>
<li>（可选择）访问控制(<em>access control</em>)，在这些配置中，排序服务作为可信的实体，限制交易的广播和指定peer节点和客户端的块的接收</li>
</ol>
<p>排序服务通过系统通道上的生成块进行引导。生成块携带了配置事务(<em>configuration transaction</em>)，定义了排序服务的操作。</p>
<p>当前版本的实现由OSN组成，OSN实现了描述的操作并且通过系统通道通信。实际的<em>atomic broadcast</em>函数由基于<em>ZooKeeper</em>的Kafka实例提供，这个实例提供了可以扩展的发布-订阅消息，在节点崩溃后仍具有强一致性(<em>consistency</em>)。这个实现可以运行在与OSN分离的物理节点上。OSN作为peers和Kafka实例之间的代理。</p>
<p>OSN直接将收到的新交易注入到广播中。OSN将从广播中接收到的交易转换成块。只要满足三个情况之一，块就会被断开。</p>
<ul>
<li>区块包含了交易允许的最大值</li>
<li>区块达到最大大小</li>
<li>从接收到第一个交易后超过某特定时间</li>
</ul>
<p>批处理的过程是确定的，因此在所有节点上都会产生相同的区块。考虑到从广播中接收的交易数据流，前两项情况是已经确定的。对于第三个条件，当节点读入块中的第一个交易时，会开启一个计时器。如果计时器超时后，这个区块仍然没有断开，OSN会在通道上广播一个特殊的“到时断开(<em>time-to-cut</em>)”交易，其中记录了需要断开的区块的序列号。另一方面，每个OSN在收到“到时断开”交易后，会根据其给定的序列号，立即切断新的区块。这个交易是原子性的分发给所有连接的OSN，所以区块中都包含相同的交易列表。OSN将最近交付的一系列区块直接持久化到文件系统中，因此可以通过分发回答peer节点来回收区块。</p>
<h2 id="Peer-Gossip"><a href="#Peer-Gossip" class="headerlink" title="Peer Gossip"></a>Peer Gossip</h2><p>将三个阶段分开的好处是在开发的时候可以独立扩展。然而，由于共识算法往往有带宽限制，排序服务的吞吐量被节点的网络容量所限制。共识无法通过增加节点而扩展，反而会让吞吐量降低。然而，由于排序和验证是分开的，在排序阶段后，重要的是如何有效地广播执行阶段的结果，以交给peer节点进行验证。此外，还有如何对新加入的peer节点和长期断开的peer节点进行状态转移。这两个问题就是gossip组件所需要解决的。Fabric gossip利用流行组播(<em>epidemic multicast</em>)来解决这个问题。区块是由排序服务签署的。这意味着一个peer节点在收到所有区块后，可以独立的组装为区块链并验证其完整性。</p>
<p>gossip的通信基于gRPC，利用TLS（传输层安全协议）进行相互识别，使得每一方都可以将TLS凭证与远程peer节点的身份绑定。gossip组件用来维护系统中当前在线的peer节点的成员视图。所有的peer节点通过定期传播成员数据独立建立一个本地视图。此外，一个peer节点可以在网络崩溃或者中断后重新连入成员视图。</p>
<p>Fabric的gossip组件采用了两个阶段进行信息的传播：</p>
<ul>
<li>在<em>push</em>阶段，每个peer节点从成员视图中选择一个随机的活跃邻居集合，并向他们发送信息</li>
<li>在<em>pull</em>阶段，每个peer节点定期探测一个随机选择的peer节点集合，并请求缺失的信息</li>
</ul>
<blockquote>
<p>研究表明，同时使用这两种方法可以优化可用带宽并确保所有peer节点有很高的概率接收到所有信息。</p>
</blockquote>
<p>为了减少从排序节点向网络中发送的区块的负载，协议同时在peer中选择了一个领导者(<em>elects a leader peer</em>)，代表peer节点从排序服务中<em>pull</em>区块，并启动gossip分发。这个机制对领导者出现故障具有弹性。</p>
<h2 id="分布式账本-Ledger"><a href="#分布式账本-Ledger" class="headerlink" title="分布式账本(Ledger)"></a>分布式账本(<em>Ledger</em>)</h2><p>账本组件在各个peer节点中维持分布式账本并建立持久性的存储，并实现账本的模拟、验证和更新阶段。整体上由一个区块存储(<em>block store</em>)和一个peer节点交易管理器(<em>peer transaction manager</em>)组成。</p>
<h3 id="区块存储-Ledger-Block-Store"><a href="#区块存储-Ledger-Block-Store" class="headerlink" title="区块存储(Ledger Block Store)"></a>区块存储(Ledger Block Store)</h3><p>账本区块存储持久化交易区块，并以一组仅追加文件的形式实现。由于区块无法被改变，并以一个特定的顺序到达，一个仅追加的结构能够带来最好的性能。此外，区块存储中维护了一些索引(<em>indices</em>)，用来随机访问区块或区块中的交易。</p>
<h3 id="peer交易管理器-Peer-Transaction-Manager"><a href="#peer交易管理器-Peer-Transaction-Manager" class="headerlink" title="peer交易管理器(Peer Transaction Manager)"></a>peer交易管理器(Peer Transaction Manager)</h3><p>peer节点交易管理器(PTM)保持版本键值对处于最新状态。它能为每一个唯一的条目(<em>entry</em>)的<em>key</em>以(<em>key</em>,<em>val</em>, <em>ver</em>)存储一个元组，其中包含了最近存储的值<em>val</em>，和最新的版本号<em>var</em>。版本由区块序列号和区块内的交易序列号组成，因此版本号都是唯一且递增的。PTM使用了本地键值存储来识别版本变量，具体实现使用了LevelDB和Apache CouchDB。</p>
<p>在模拟时，PTM提供了一个稳定的最新状态快照。<strong>执行阶段</strong>中提到，PTM在<em>readset</em>中为GetState访问的每个条目记录一个元组(<em>key</em>, <em>ver</em>)，在<em>writeset</em>中为交易调用PutState更新的每个条目记录一个元组(<em>key</em>, <em>val</em>)。此外，PTM支持范围查询(<em>range queries</em>)，并计算出查询结果的加密哈希（一组(<em>key</em>, <em>ver</em>)元组），并将查询字符串和哈希添加到readset中。</p>
<p>在验证阶段，PTM依次验证一个区块中的所有交易，检查交易是否与之前的任何交易产生冲突。对于readset中的所有key，如果readset中的版本记录与最新状态的版本不同，PTM就会把这个交易标记为无效。对于范围查找，PTM会重新执行查询并与之前的<em>readset</em>比较哈希值，确保不发生错误的读取。</p>
<h3 id="崩溃处理"><a href="#崩溃处理" class="headerlink" title="崩溃处理"></a>崩溃处理</h3><p>账本组件在更新时需要能处理peer节点的崩溃。</p>
<p>在接收到一个新区块后，PTM已经对其进行了验证，并使用了掩码将区块中的交易标记为有效或无效。此时，账本将区块写入账本的区块存储中，刷新到磁盘，随后更新区块存储的索引。随后，PTM将所有有效交易的<em>writeset</em>状态变化应用到本地存储中。最后，计算并持久化一个<em>savepoint</em>的值，表示成功应用区块数量的最大值。从崩溃中恢复时，<em>savepoint</em>值用来从持久化块中恢复索引和最新状态。</p>
<h2 id="链码执行"><a href="#链码执行" class="headerlink" title="链码执行"></a>链码执行</h2><p>Chaincode在一个与其余peer节点松散耦合的环境中执行。支持增添新的链码编程语言的插件。目前支持Go、Java和Node。</p>
<p>每个用户级或应用链码都在Docker容器环境中的独立进程中执行，这使得链码和peer节点之间相互隔离，简化了链码的生命周期管理（启动、停止、中止）。链码和peer节点通过gRCP通信。通过松散的耦合关系，peer节点不知道链码具体使用了什么语言实现。</p>
<p>不同于应用链码，系统链码直接在peer节点的进程中运行，可以实现Fabric所需要的特定功能，可以用于用户链码之间的隔离限制过多的情况。</p>
<h2 id="配置和系统链码"><a href="#配置和系统链码" class="headerlink" title="配置和系统链码"></a>配置和系统链码</h2><p>Fabric通过通道配置(<em>channel configuration</em>)和系统链码(<em>system chaincodes</em>)进行定制。</p>
<p>Fabric中每个通道都会形成一个逻辑区块链。通道的配置由元数据进行维护，并永久保留在配置区块(<em>configuration blocks</em>)中。每个配置区块都会包含完整的通道配置，并不会包括任何其他的东西。每个区块链都以一个配置区块开始，称之为创世块(<em>genesis block</em>)，用于引导通道。通道的配置包括：</p>
<ol>
<li>参与节点的MSP定义；</li>
<li>OSN的网络地址；</li>
<li>共识实现和配许服务的共享配置，比如大小和超时等设置；</li>
<li>管理对排序服务操作（广播和分发）访问的规则；</li>
<li>管理如何修改通道配置的各个部分的规则。</li>
</ol>
<p>通道的配置可以使用通道配置更新事务(<em>channel configuration update transaction</em>)进行更新，其中需要包括对配置进行的修改和一组签名。排序节点通过使用当前的配置验证该签名是否得到授权，来评估此次更新是否有效。然后，排序节点生成一个新的配置区块，嵌入新的配置和配置更新事务。Peer节点接收后，根据当前的配置验证更新是否得到了授权，有效则进行配置更新。</p>
<p>在部署应用链码时，会<u>参考</u>一个认可系统链码（<em>endorsement system chaincode</em>, ESCC）和一个验证系统链码（<em>validation system chaincode</em>, VSCC）。这两个链码的选择使得ESCC输出的背书，可以作为VSCC输入的一部分进行验证。ESCC将一个提案和提案模拟的结果作为输入。如果结果符合要求，则ESCC产生一个包含结果和认可的响应。对于默认的ESCC，这个背书只是peer节点的本地签名身份的签名。VSCC将一个事务作为输入，并输出该事务是否有效。对于默认的VSCC，背书被收集，并根据为链码指定的背书策略进行评估。进一步的系统链码实现其他支持功能，如链码生命周期。</p>
<blockquote>
<p>系统链码的核心代码在/fabric/core/common/sysccprovider和/fabric/core/scc下</p>
</blockquote>
<h1 id="学习思路"><a href="#学习思路" class="headerlink" title="学习思路"></a>学习思路</h1><p><img data-src="RodeToFabric.jpg" alt="1.0版本学习思路"></p>
]]></content>
      <tags>
        <tag>crypto</tag>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/11/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>基物实验</title>
    <url>/2020/11/17/%E5%9F%BA%E7%89%A9%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>记录一下自己做实验时的各种坑与总结的经验，以后可以提醒提醒学弟。</p>
<a id="more"></a>
<h1 id="分光仪"><a href="#分光仪" class="headerlink" title="分光仪"></a>分光仪</h1><p>实验时间：2020年9月21日</p>
<p>这是我做的第一个实验，成功AK（手动狗头）</p>
<h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2><p>第一步的粗调非常重要，决定了你接下来的调整速度。个人经验是在实验前千万不要去玩那些螺丝，也许上个人已经调好了，上来随便调一调就合格，可以直接做实验。</p>
<p>按照正常的方法去调整就行，遇到的唯一困难就是转180°后找不到绿十字了，这时可以考虑先用眼睛去找，确定了绿十字反射回来的位置之后再去调目镜和平台，后面按照视频里或者老师讲的做就可以，应该没什么难度。</p>
<h2 id="测量三棱镜的顶角"><a href="#测量三棱镜的顶角" class="headerlink" title="测量三棱镜的顶角"></a>测量三棱镜的顶角</h2><p>这个实验还是挺水的。。。随便测测就行了。顶角是60°，测量结果应该是120°</p>
<h2 id="最小偏向角法测量棱镜的折射率"><a href="#最小偏向角法测量棱镜的折射率" class="headerlink" title="最小偏向角法测量棱镜的折射率"></a>最小偏向角法测量棱镜的折射率</h2><p>这个实验最大的坑就是“最小偏向角”一定要旋转三棱镜的摆放位置，直到折射光的偏转最小。（折射光在右手边就让光尽可能靠左，左手边就尽可能靠右）</p>
<p>后面应该就不需要去动三棱镜了，钠光的入射光应该是可以找到的。</p>
<p>最终的测量结果应该在50°50′左右。</p>
<h2 id="掠入射法测量棱镜的折射率"><a href="#掠入射法测量棱镜的折射率" class="headerlink" title="掠入射法测量棱镜的折射率"></a>掠入射法测量棱镜的折射率</h2><p>当时做这个实验的时候主要是不知道怎么摆放。。。好在最后找了个做过的大佬，画了个草图。</p>
<p><img data-src="掠入射测量棱镜的折射率.jpg" alt=""></p>
<p>最终的测量结果应该在39°左右。</p>
<p>如果时间不够用的话，一个省时间的技巧是在测下一组数据的时候不动目镜，只转动刻度盘，这样就可以少调整一次。（如果彻底没有时间了，那就测量一组，然后写到第五组的位置上，剩下的数据全靠编。我室友就这么硬水过的。。。）</p>
<h2 id="干涉法测平板玻璃折射率"><a href="#干涉法测平板玻璃折射率" class="headerlink" title="干涉法测平板玻璃折射率"></a>干涉法测平板玻璃折射率</h2><p>这个实验做了也不算积分，而且至少要1小时的时间，所以就没做（也没人做）。</p>
<h1 id="示波器"><a href="#示波器" class="headerlink" title="示波器"></a>示波器</h1><p>实验时间：2020年10月26日</p>
<p>做的第一个非光学实验（绪论除外），没能AK，后面就决定重回光学的怀抱了。</p>
<h2 id="示波器的使用"><a href="#示波器的使用" class="headerlink" title="示波器的使用"></a>示波器的使用</h2><p>这个还是挺简单的，但建议速度一定要快，给后面两个实验留点时间。</p>
<p>需要注意的是，这个实验老师是会查现象的，所以最好不要尝试去水。其实水的目的不是混分，都是现象做出来了，只是时间不够时的一个手段而已，非常不建议滥用，毕竟做出实验现象还是很爽的。</p>
<h2 id="二极管伏安特性曲线"><a href="#二极管伏安特性曲线" class="headerlink" title="二极管伏安特性曲线"></a>二极管伏安特性曲线</h2><p>当时按照电路图连了电路，结果发现线貌似不够用，打算先测量声速。</p>
<p>然后就没有然后了</p>
<h2 id="声速测量"><a href="#声速测量" class="headerlink" title="声速测量"></a>声速测量</h2><p>测量声速的时候遇到了好几个坑。</p>
<ol>
<li>实验前和实验后一定要记得调整频率，使得振幅最大，并记录下来。</li>
<li>实验的线材和器材有毒，各种连接不稳定，最后是用笔袋支撑着线才能做实验的。</li>
<li>我当时老师要求振幅法和李萨如法都要用，很耽误时间，建议先做第二个实验。不过我当时的老师人比较好，让我们几个人拖延了一会，硬是把数据记完了，而且没有查实验器材。</li>
</ol>
<h1 id="迈克尔逊干涉"><a href="#迈克尔逊干涉" class="headerlink" title="迈克尔逊干涉"></a>迈克尔逊干涉</h1><p>实验时间：2020年11月9日</p>
<p>第二个光学实验，也AK了。让人不禁感叹，光学实验真的是适合刷积分啊。</p>
<h2 id="迈克尔逊干涉-1"><a href="#迈克尔逊干涉-1" class="headerlink" title="迈克尔逊干涉"></a>迈克尔逊干涉</h2><p>这个实验老师会讲好久（但里面有不少干货，建议认真听），我当时足足讲了1小时20分钟，讲到最后我都直接开激光偷偷调整了。</p>
<p>整个调整步骤有四步，一步一步来就行，别忘了第一步是调激光入射光就行（我做完实验才发现这个事情，还好最后没出现问题）。如果发现自己找不到水平一排的三个亮点，可能是入射光没有完全射到各个镜子上，调整的时候出现问题了还是动脑子想一想吧，毕竟遇到的问题真的是各种各样的都有。</p>
<p>如果发现迈克尔逊环很密的话，可能是反射镜位置不太对，调整到老师推荐的位置，然后拧一拧应该就能出来。</p>
<p>装置的空程差真的让人绝望，我一开始大概转了60圈才消除掉，</p>
<p>数的时候真的可能会数错。。。建议十个十个数。技巧就是一定要数内缩环，外扩真的纠结应该数到哪里。</p>
<h2 id="牛顿环干涉"><a href="#牛顿环干涉" class="headerlink" title="牛顿环干涉"></a>牛顿环干涉</h2><p>感觉牛顿环是最简单的实验了，只需要调好反射镜的位置和目镜的高度就行。重点是不要数错环，我当时是从11数到20。。。建议从6数到15。</p>
<p>数错了重新数其实也浪费不了多少时间，如果懒的话就继续编数据大法吧。。。</p>
<h2 id="劈尖干涉"><a href="#劈尖干涉" class="headerlink" title="劈尖干涉"></a>劈尖干涉</h2><p>这个实验的劈尖干涉应该是来得及做的，我当时最后有几十分钟的时间来纠结应该怎么做（其实想法一直都没问题，但我的仪器测量范围有问题，浪费了巨量时间）。当时认识的大佬没做这个实验，于是只能自己摸索了。下面是我总结的实验步骤。</p>
<ol>
<li><p>本实验的样本无须自己制作。</p>
</li>
<li><p>做实验过程中遇到的唯一障碍在于测量“细丝位置到尖端的距离”。我遇到的样本为一张纸，因此与图片中的细丝有些小差别。实际操作中的装置如下图所示（左侧是尖端，右侧的小横线是纸张）。图片中的L就是需要测量的部分。具体做法大致就是把装置侧过来，显微镜对焦，然后从尖端量到纸张即可。</p>
<p><img data-src="劈尖装置示意图.jpg" alt=""></p>
</li>
<li><p>我用的仪器貌似有问题。。。小于25mm的部分手轮转不过去，最后还是借室友的仪器做的……</p>
</li>
<li><p>在测量干涉条纹宽度时，显微镜物镜可能会被螺丝卡住，建议把装置倒过来测量，把四个突出来的螺丝放在下面当支柱。。。</p>
</li>
<li><p>我的测量结果是$L\approx39\ \mathrm{mm}$, $n=5$时$l\approx5.6\ \mathrm{mm}$。反正最后处理时别忘了还有个$n$就行，刚开始算出来的结果给我人都看傻了，最后算的大概是$50\mu m$，感觉小了一些，不过至少还有点靠谱。</p>
</li>
</ol>
<h1 id="钠光干涉"><a href="#钠光干涉" class="headerlink" title="钠光干涉"></a>钠光干涉</h1><p>时间：2020年11月16日</p>
<p>第三个光学实验，第一个非必修实验。</p>
<p>这次没有AK（这句话导致我险些被室友暴打）。还是大意了，没有闪。</p>
<h2 id="钠光双棱镜"><a href="#钠光双棱镜" class="headerlink" title="钠光双棱镜"></a>钠光双棱镜</h2><p>本实验的仪器调整步骤很坑，耽误了巨量时间。。。最后只能卡点强行搞完双棱镜的实验。</p>
<p>我最后总结的调整方法：</p>
<ol>
<li>前面用ppt或者书上的方法都行，毕竟各个元器件的高度之类的还是比较好调的。</li>
<li>到最后找大小像和干涉条纹时，一定要先找干涉条纹，老师也强调了，但没说怎么操作。。。搞得我各种前后移动最后还是找不到。最后发现是双棱镜和狭缝不平行所导致的。</li>
<li>最好的方法是先参考别人的报告摆放好狭缝和双棱镜的位置（这样可以确保有20个条纹），让目镜紧贴双棱镜，旋转双棱镜或调整狭缝宽度以找到清晰的干涉条纹，再把目镜拉到正确的位置，找大小像并把叉丝调到中心。</li>
<li>实验室的双棱镜上半部分是空的，会漏光。所以如果发现目镜拉远后干涉条纹被光盖住了，可以试试把双棱镜位置提高一点。</li>
</ol>
<p>另外，感觉目镜手轮的4和5很容易读错，读的时候一定要注意一点。仪器的位置最好和已有实验报告的位置差不多，可以对着别人的数据检查，不然最后数据偏差过大就傻了。这种东西能水过去就尽量水过去吧。。。</p>
<h2 id="钠光劳埃镜"><a href="#钠光劳埃镜" class="headerlink" title="钠光劳埃镜"></a>钠光劳埃镜</h2><p>勉强做完双棱镜，gg。祝xdm好运。</p>
<h1 id="稳态法测不良导体热导率"><a href="#稳态法测不良导体热导率" class="headerlink" title="稳态法测不良导体热导率"></a>稳态法测不良导体热导率</h1><p>时间：2020年12月5日</p>
<p>第一个热学实验，英文实验+研究性实验</p>
<p>热学实验就离谱。把装置调好之后等着就行了，建议带个作业去写，或者把器材的数据简单处理一下。大概得等1个多小时吧，加热盘温度到达75℃之后再等散热盘温度稳定就行了。实际操作的时候不一定非要到75℃，毕竟示数会有误差，加到74.9℃之后发现一直没变化就可以记录了。（试验台在过道边上是真的坑，走来走去的对实验结果真的有影响）</p>
<p>英文实验熟悉了老师的口语之后还是可以听懂的。我当时的老师人很好，和他说了想做研究性实验之后说可以让我们待到下午上课前，后来直接让我们去没人的实验台做实验了。</p>
<p>我做的研究性实验就是做了个无风扇的实验，然后两个实验进行对比，结论是有风扇实验系统误差高，无风扇实验偶然误差高，并为实验在风扇上提出了两个改进方案。做研究性实验的话建议去知网找找，我就是在知网找到一篇比较风扇的论文，然后自己做实验，实验原理找了个物竞大佬教。</p>
<p>（感觉上课和老师聊研究性实验的时候，全班同学都在用一种怪异的眼神看着我…）</p>
<h1 id="绪论实验"><a href="#绪论实验" class="headerlink" title="绪论实验"></a>绪论实验</h1><p>实验时间：2020年10月12日</p>
<p>绪论实验没什么好说的，就是上来会有个小测验，建议稍微准备一下。我那次雨课堂测试，十几个人平均分3.8/10，就nm离谱。</p>
<p>绪论的报告要求会略高一点点，既要列出公式也要把数值带进去的式子写上，最后再写答案。计算步骤直接上知乎抄吧。</p>
<p>听说最后的给分都挺低，4分就算不错了。也不知道是不是真的。</p>
]]></content>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>not RSA WriteUp</title>
    <url>/2020/12/09/not-RSA-WriteUp/</url>
    <content><![CDATA[<p>题目来源：安恒四月赛（DASCTF 2020）</p>
<a id="more"></a>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> AITMCLab.libnum <span class="keyword">import</span> gcd, invmod, s2n</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> isPrime</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line">p = <span class="number">104879397075344024438671231239628115011303349344697797964879592144922079000957</span> </span><br><span class="line">q = <span class="number">104879397075344024438671231239628115011303349344697797964879592144922079001013</span></span><br><span class="line"><span class="keyword">assert</span> isPrime(p) <span class="keyword">and</span> isPrime(q)</span><br><span class="line">n = p * q</span><br><span class="line">flag = s2n(flag)</span><br><span class="line">r = randint(<span class="number">1</span>, n)</span><br><span class="line">c = (<span class="built_in">pow</span>(n + <span class="number">1</span>, flag, n * n) * <span class="built_in">pow</span>(r, n, n * n)) % (n * n)</span><br><span class="line"><span class="built_in">print</span> c</span><br><span class="line"><span class="comment"># c = 13134489820394613222282607681686272081419875146946401883172682167011759113388373349180457979897848113275982219264879081189886853062717764580364698888338032141434053832247476010400449272010082460437747190468766740274587999336359171283098137261396013153130265440425676242061845667887640808895666325466803989428</span></span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>代码很简单，就是道纯数学题</p>
<p>由源码：</p>
<p>$c\equiv (n+1)^f\cdot r^n\ (\mathrm{mod}\ n^2)$</p>
<p>根据二项式定理：</p>
<p>$c\equiv (fn+1)\cdot r^n\ (mod\ n^2)$</p>
<p>左右两式同乘$\varphi(n)$次方，得$c^{\varphi(n)}\equiv (fn+1)^{\varphi(n)}\cdot r^{n\varphi(n)}\ (mod\ n^2)$</p>
<p>由$\varphi(n^2)=n\cdot \varphi(n)$且当$r\neq p$或$r\neq q$时有，$gcd(r,n)=1$可知，$r^{n\varphi(n)}\equiv 1\ (mod\ n^2)$，可得：</p>
<p>$c^{\varphi(n)}\equiv (fn+1)^{\varphi(n)}\ (mod\ n^2)$</p>
<p>因为r为随机数，所以$r\neq p,q$的概率为$\dfrac{2}{n}$，可认为$gcd(r,n)=1$成立。</p>
<p>再次使用二次项定理，可得$c^{\varphi(n)}\equiv fn\varphi(n)+1\ (mod\ n^2)$</p>
<p>由费曼小定理可知$c^{\varphi(n)}\equiv 1\ (mod\ n)$，即$n|c^{\varphi(n)}-1$，因此将1移到同余式左边并对同余式同除n，得：</p>
<p>$\dfrac{c^{\varphi(n)}-1}{n}\equiv f\varphi(n)\ (mod\ n)$</p>
<p>对于左式，设$\dfrac{c^{\varphi(n)}-1}{n}=kn+r’$</p>
<p>$c^{\varphi(n)}=kn^2+rn+1$</p>
<p>只需求解出$rn+1$即可，因此可以对$c^{\varphi(n)}$进行模$n^2$，实现时可直接使用python中的pow函数。</p>
<p>将左式求解后，化为求解$\varphi(n)\cdot f\equiv r’\ (mod\ n)$，即$f\equiv \varphi(n)^{-1}\cdot r’\ (mod\ n)$</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> AITMCLab.libnum <span class="keyword">import</span> s2n, invmod, n2s</span><br><span class="line"></span><br><span class="line">c = <span class="number">131344898203946132222826076816862720814198751469464018831726821670</span> <span class="number">117591133883733491804579798978481132759822192648790811898868530627</span> <span class="number">177645803646988883380321414340538322474760104004492720100824604377</span> <span class="number">471904687667402745879993363591712830981372613960131531302654404256</span> <span class="number">76242061845667887640808895666325466803989428</span></span><br><span class="line">p = <span class="number">104879397075344024438671231239628115011303349344697797964879592144</span> <span class="number">922079000957</span> </span><br><span class="line">q = <span class="number">104879397075344024438671231239628115011303349344697797964879592144</span> <span class="number">922079001013</span></span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">n = p * q</span><br><span class="line">r = (<span class="built_in">pow</span>(c, phi_n, n * n) - <span class="number">1</span>) // n</span><br><span class="line"><span class="built_in">print</span> n2s(r * invmod(phi_n, n) % n)</span><br></pre></td></tr></table></figure>
<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>flag\{can_you_find_me??\}</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>纯数学题</p>
<p>学长带着推了一遍。。。这也太难了。。。</p>
<p>听说是<em>paillier</em>加密，果然不是RSA</p>
]]></content>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>BabyRSA WriteUp</title>
    <url>/2020/12/09/BabyRSA-WriteUp/</url>
    <content><![CDATA[<p>题目来源：N1CTF 2019</p>
<a id="more"></a>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line">N = <span class="number">23981306327188221819291352455300124608114670714977979223022816906368788909398653961976023086718129607035805397846230124785550919468973090809881210560931396002918119995710297723411794214888622784232065592366390586879306041418300835178522354945438521139847806375923379136235993890801176301812907708937658277646761892297209069757559519399120988948212988924583632878840216559421398253025960456164998680766732013248599742397199862820924441357624187811402515396393385081892966284318521068948266144251848088067639941653475035145362236917008153460707675427945577597137822575880268720238301307972813226576071488632898694390629</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">m = number.bytes_to_long(flag)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;flag.enc&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> m:</span><br><span class="line">        padding = random.randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">1000</span>) ** <span class="number">2</span></span><br><span class="line">        message = padding &lt;&lt; <span class="number">1</span> + m % <span class="number">2</span></span><br><span class="line">        cipher = <span class="built_in">pow</span>(message, e, N)</span><br><span class="line">        f.write(<span class="built_in">hex</span>(cipher)+<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">        m /= <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先阅读代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> m:</span><br><span class="line">    <span class="comment"># several operations</span></span><br><span class="line">    m /= <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>由上述代码部分以及过程中出现了<code>m % 2</code>操作可知，flag的二进制数据每一位被存进了<code>key.enc</code>文件的每行数据中，因此对<code>key.enc</code>文件的每一行进行读取，只要能够判断该位为0还是1，即可完成解密。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">padding = random.randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">1000</span>) ** <span class="number">2</span></span><br><span class="line">message = padding &lt;&lt; <span class="built_in">pow</span>(m, p - <span class="number">1</span>, p) + m % <span class="number">2</span></span><br><span class="line">cipher = <span class="built_in">pow</span>(message, e, N)</span><br></pre></td></tr></table></figure>
<p>由上述代码可知，$c\equiv m^e\ (\mathrm{mod}\ N), m = r^2\cdot 2^{1+flag\%2}$ （r为random结果），因此<code>m%2=1</code>时，有$c\equiv r^2\cdot 2^2\equiv (2^er^e)^2\ (\mathrm{mod}\ N)$，而<code>m%2=0</code>时，有$c\equiv 2^e\cdot r^{2^e}$。</p>
<p>首先猜测可以通过破解RSA密码，将加密信息还原为明文信息，判断该数整除2的奇数次方还是偶数次方即可得知该位的二进制数。使用factordb网站失败后贼心不死，又尝试了网上找的多种攻击脚本，发现均无法分解，于是寻找其它方法。</p>
<p>观察<del>README.md</del>发现，本题可以尝试用二次剩余求解。<code>m%2=1</code>时，有$c\equiv (2^er^e)^2\ (\mathrm{mod}\ N)$，<code>m%2=0</code>时，有$c\equiv (2\cdot r^2)^e\ (\mathrm{mod}\ N)$，因此，当c为N的二次剩余时，对应<code>m%2=1</code>，c为N的二次非剩余时，对应<code>m%2=0</code>。</p>
<p>可以使用Jacobi判断是否为二次剩余。只需满足$\left(\dfrac{2^e\cdot r^{2^e}}{N}\right)=-1$即可求解。由于$\left(\dfrac{2^e\cdot r^{2^e}}{N}\right)=\left(\dfrac{2}{p}\right)\left(\dfrac{2}{q}\right)$，所以当<code>m%2=0</code>时，Jacobi计算结果仅取决于p和q，且在实际计算中发现存在Jacobi计算结果为-1的情况，又因为<code>m%2=1</code>时Jacobi计算结果必然为1，说明本题中2分别是p和q的二次剩余和二次非剩余，可得下式</p>
<script type="math/tex; mode=display">
\left(\dfrac{c}{N}\right)= \begin{cases}\left(\dfrac{2}{p}\right)\left(\dfrac{2}{q}\right)=-1,m\%2=0\\1, m\%2=1\end{cases}</script><p>因此可以用Jacobi来计算flag的二进制结果。</p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> AITMCLab.Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jacobi</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>) ** ((b * b - <span class="number">1</span>) / <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">if</span> a == b - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>) ** ((b - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        res *= jacobi(<span class="number">2</span>, b)</span><br><span class="line">        a /= <span class="number">2</span></span><br><span class="line">    res *= (<span class="number">-1</span>)**((a - <span class="number">1</span>) * (b - <span class="number">1</span>) / <span class="number">4</span>) * jacobi(b % a, a)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">n = <span class="number">23981306327188221819291352455300124608114670714977979223022816906368788909398653961976023086718129607035805397846230124785550919468973090809881210560931396002918119995710297723411794214888622784232065592366390586879306041418300835178522354945438521139847806375923379136235993890801176301812907708937658277646761892297209069757559519399120988948212988924583632878840216559421398253025960456164998680766732013248599742397199862820924441357624187811402515396393385081892966284318521068948266144251848088067639941653475035145362236917008153460707675427945577597137822575880268720238301307972813226576071488632898694390629</span></span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;key.enc&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        line = line.strip(<span class="string">&quot;L\n&quot;</span>)    <span class="comment"># Filter out &quot;L\n&quot; at the end of line</span></span><br><span class="line">        cur = <span class="built_in">int</span>(line, <span class="number">16</span>)         <span class="comment"># Convert hax string to number</span></span><br><span class="line">        <span class="keyword">if</span> (jacobi(cur, n) == <span class="number">1</span>):</span><br><span class="line">            flag += <span class="number">1</span> &lt;&lt; i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span> flag</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> flag</span><br><span class="line"><span class="built_in">print</span> long_to_bytes(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先从<code>key.enc</code>中逐行读取，并对每一行结尾的’L\n’进行过滤，将其转换为整数cur后，计算Jacobi符号$J\left( cur, N\right)$。计算Jacobi符号时主要使用二次互反律进行计算（可以再使用其它定律进行加速，但没必要）。</p>
<p>由于第一行储存的为flag的最后一位（即从后往前储存），因此进行<code>flag += 1 &lt;&lt; i</code>即可将相应位置的二进制结果还原。</p>
<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>N1CTF\{You_can_leak_the_jacobi_symbol_from_RSA\}</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题在代码阅读上难度较低，唯一需要留意的地方就是<code>padding &lt;&lt; pow(m, p - 1, p) + m % 2</code>这个运算的优先级问题（感谢bg的注释提示）。把代码转换成数学公式后，二次剩余的方法就比较明显了，需要注意的是<code>Jacobi</code>符号无法准确判断二次剩余与二次非剩余（感谢bg指出了这个问题），简单推导后发现这个方法有一定的使用条件，如果题目中的p和q不满足一定的条件，这个方法就无法正确区分0和1。</p>
<hr>
<p>后经大佬提醒发现这道题用的是Goldwasser-Micali密码（上课走神实锤了）。简单对比发现，当GM密码选取的x满足<code>J(x, p) = 1</code>且<code>J(x, q) = -1</code>时，可能能够利用本题的方法进行破解。因此选取的x不能仅满足是n的二次非剩余，需要同时是p和q的二次非剩余。</p>
]]></content>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC 介绍</title>
    <url>/2020/12/11/gRPC-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>学习gRPC框架原理</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>A high-performance, open-source universal RPC framework</p>
</blockquote>
<p>gRPC框架具有高性能，开源，跨语言的特点，使用了RPC框架，基于HTTP/2设计。</p>
<blockquote>
<p>RPC(<em>remote procedure call</em>，远程过程调用)框架提供了一套机制，使得应用程序之间可以进行通信，遵从server/client模型。<br>RPC将一个服务调用封装在一个本地方法中，让调用者像使用本地方法一样调用服务，对其屏蔽实现细节。具体的实现则通过调用方和服务方的协议，基于TCP连接进行数据交互达成。</p>
<p>在本地调用过程中，通常需要通过接口，调用具体实现，最终获取相应的数据。<br>而在RPC中，本地获取到接口，随后通过网络，调用远程的实现。在使用网络时，需要通过数据序列化来传输数据。</p>
</blockquote>
<p>在gRPC中，支持多个语言的应用程序的远程调用，数据交换格式则采用了<em>Protocol Buffer</em>。</p>
<p><img data-src="gRPC-basic.png" alt="gRPC-basic"></p>
<p>如上图所示，左侧为c++语言编写的客户端，其中包含了接口的具体实现。右侧为Ruby和Java客户端，其中对接口进行了调用。客户端获取接口后，将数据通过<em>Protocol Buffer</em>的序列化处理后交给服务端，服务端调用具体实现，并把数据同样以序列化的形式返回给客户端。</p>
]]></content>
      <tags>
        <tag>fabric</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric-系统链码</title>
    <url>/2020/12/18/Fabric-%E7%B3%BB%E7%BB%9F%E9%93%BE%E7%A0%81/</url>
    <content><![CDATA[<p>Fabric系统链码部分</p>
<a id="more"></a>
<h1 id="系统链码"><a href="#系统链码" class="headerlink" title="系统链码"></a>系统链码</h1><p><img data-src="系统链码结构图.png" alt="系统链码结构图"></p>
<h1 id="Querier-System-Chaincode-QSCC"><a href="#Querier-System-Chaincode-QSCC" class="headerlink" title="Querier System Chaincode (QSCC)"></a>Querier System Chaincode (QSCC)</h1><blockquote>
<p>/core/scc/qscc/query.go</p>
</blockquote>
<p>提供账本查询接口，获取块和交易信息等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> qscc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span>                       <span class="comment">// 格式化IO</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span>                   <span class="comment">// 数据类型转换</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric-chaincode-go/shim&quot;</span></span><br><span class="line">	pb <span class="string">&quot;github.com/hyperledger/fabric-protos-go/peer&quot;</span> <span class="comment">// 调用.pb.go文件，由proto文件生成</span></span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric/common/flogging&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric/core/aclmgmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric/core/ledger&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric/protoutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LedgerGetter gets the PeerLedger associated with a channel.</span></span><br><span class="line"><span class="keyword">type</span> LedgerGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetLedger(cid <span class="keyword">string</span>) ledger.PeerLedger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns an instance of QSCC.</span></span><br><span class="line"><span class="comment">// Typically this is called once per peer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(aclProvider aclmgmt.ACLProvider, ledgers LedgerGetter)</span> *<span class="title">LedgerQuerier</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;LedgerQuerier&#123;</span><br><span class="line">		aclProvider: aclProvider,</span><br><span class="line">		ledgers:     ledgers,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (e *LedgerQuerier) 表示这是LedgerQuerier结构体的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *LedgerQuerier)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span>              &#123; <span class="keyword">return</span> <span class="string">&quot;qscc&quot;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *LedgerQuerier)</span> <span class="title">Chaincode</span><span class="params">()</span> <span class="title">shim</span>.<span class="title">Chaincode</span></span> &#123; <span class="keyword">return</span> e &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LedgerQuerier implements the ledger query functions, including:</span></span><br><span class="line"><span class="comment">// - GetChainInfo returns BlockchainInfo</span></span><br><span class="line"><span class="comment">// - GetBlockByNumber returns a block</span></span><br><span class="line"><span class="comment">// - GetBlockByHash returns a block</span></span><br><span class="line"><span class="comment">// - GetTransactionByID returns a transaction</span></span><br><span class="line"><span class="keyword">type</span> LedgerQuerier <span class="keyword">struct</span> &#123;</span><br><span class="line">	aclProvider aclmgmt.ACLProvider</span><br><span class="line">	ledgers     LedgerGetter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> qscclogger = flogging.MustGetLogger(<span class="string">&quot;qscc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// These are function names from Invoke first parameter</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	GetChainInfo       <span class="keyword">string</span> = <span class="string">&quot;GetChainInfo&quot;</span></span><br><span class="line">	GetBlockByNumber   <span class="keyword">string</span> = <span class="string">&quot;GetBlockByNumber&quot;</span></span><br><span class="line">	GetBlockByHash     <span class="keyword">string</span> = <span class="string">&quot;GetBlockByHash&quot;</span></span><br><span class="line">	GetTransactionByID <span class="keyword">string</span> = <span class="string">&quot;GetTransactionByID&quot;</span></span><br><span class="line">	GetBlockByTxID     <span class="keyword">string</span> = <span class="string">&quot;GetBlockByTxID&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init is called once per chain when the chain is created.</span></span><br><span class="line"><span class="comment">// This allows the chaincode to initialize any variables on the ledger prior</span></span><br><span class="line"><span class="comment">// to any transaction execution on the chain.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *LedgerQuerier)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">	qscclogger.Info(<span class="string">&quot;Init QSCC&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> shim.Success(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用Invoke时，args[0]为查询函数名，args[1]为chain id，在加到stub包之前为暂时的id</span></span><br><span class="line"><span class="comment">// 每个函数都需要额外的参数，如下:</span></span><br><span class="line"><span class="comment">// # GetChainInfo: 返回一个以字节为单位的BlockchainInfo对象</span></span><br><span class="line"><span class="comment">// # GetBlockByNumber: 返回args[2]中所指定的块</span></span><br><span class="line"><span class="comment">// # GetBlockByHash: 返回args[2]中的块哈希值所指定的块</span></span><br><span class="line"><span class="comment">// # GetTransactionByID: 返回args[2]中的id所指定的交易事务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *LedgerQuerier)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123; <span class="comment">// 通过args调用内部函数</span></span><br><span class="line">	args := stub.GetArgs() <span class="comment">// stub是RPC中客户端与服务器端传输的消息包，将其解包并获取args</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// args数量小于2时，返回错误信息</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;Incorrect number of arguments, %d&quot;</span>, <span class="built_in">len</span>(args)))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个args为调用的函数名，第二个args为chain ID</span></span><br><span class="line">	fname := <span class="keyword">string</span>(args[<span class="number">0</span>])</span><br><span class="line">	cid := <span class="keyword">string</span>(args[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	sp, err := stub.GetSignedProposal() <span class="comment">// 获取签名交易提议的解码对象，类型为SignedProposal</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;Failed getting signed proposal from stub, %s: %s&quot;</span>, cid, err))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	name, err := protoutil.InvokedChaincodeName(sp.ProposalBytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;Failed to identify the called chaincode: %s&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> name != e.Name() &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;Rejecting invoke of QSCC from another chaincode because of potential for deadlocks, original invocation for &#x27;%s&#x27;&quot;</span>, name))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fname != GetChainInfo &amp;&amp; <span class="built_in">len</span>(args) &lt; <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;missing 3rd argument for %s&quot;</span>, fname))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	targetLedger := e.ledgers.GetLedger(cid)</span><br><span class="line">	<span class="keyword">if</span> targetLedger == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;Invalid chain ID, %s&quot;</span>, cid))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	qscclogger.Debugf(<span class="string">&quot;Invoke function: %s on chain: %s&quot;</span>, fname, cid)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle ACL: （ACL：访问控制权限）</span></span><br><span class="line">	res := getACLResource(fname)</span><br><span class="line">	<span class="keyword">if</span> err = e.aclProvider.CheckACL(res, cid, sp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;access denied for [%s][%s]: [%s]&quot;</span>, fname, cid, err))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用相应的函数并传递参数</span></span><br><span class="line">	<span class="keyword">switch</span> fname &#123;</span><br><span class="line">	<span class="keyword">case</span> GetTransactionByID:</span><br><span class="line">		<span class="keyword">return</span> getTransactionByID(targetLedger, args[<span class="number">2</span>])</span><br><span class="line">	<span class="keyword">case</span> GetBlockByNumber:</span><br><span class="line">		<span class="keyword">return</span> getBlockByNumber(targetLedger, args[<span class="number">2</span>])</span><br><span class="line">	<span class="keyword">case</span> GetBlockByHash:</span><br><span class="line">		<span class="keyword">return</span> getBlockByHash(targetLedger, args[<span class="number">2</span>])</span><br><span class="line">	<span class="keyword">case</span> GetChainInfo:</span><br><span class="line">		<span class="keyword">return</span> getChainInfo(targetLedger)</span><br><span class="line">	<span class="keyword">case</span> GetBlockByTxID:</span><br><span class="line">		<span class="keyword">return</span> getBlockByTxID(targetLedger, args[<span class="number">2</span>])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;Requested function %s not found.&quot;</span>, fname))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为五个private方法，只能通过invoke进行调用。</span></span><br><span class="line"><span class="comment">// 五个方法在进行异常处理后，调用账本中对应的方法，并将成功或错误结果通过shim发送</span></span><br><span class="line"><span class="comment">// - getTransactionByID: 返回对应id的交易内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTransactionByID</span><span class="params">(vledger ledger.PeerLedger, tid []<span class="keyword">byte</span>)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> tid == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(<span class="string">&quot;Transaction ID must not be nil.&quot;</span>)</span><br><span class="line">	&#125; <span class="comment">// 异常：交易为空</span></span><br><span class="line"></span><br><span class="line">	processedTran, err := vledger.GetTransactionByID(<span class="keyword">string</span>(tid)) <span class="comment">// 调用ledger.PeerLedger中的方法</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;Failed to get transaction with id %s, error %s&quot;</span>, <span class="keyword">string</span>(tid), err))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bytes, err := protoutil.Marshal(processedTran) <span class="comment">// 使用proto工具进行编排 my_<span class="doctag">TODO:</span> read protoutil</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> shim.Success(bytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下四个方法的整体结果与第一个相似</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBlockByNumber</span><span class="params">(vledger ledger.PeerLedger, number []<span class="keyword">byte</span>)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> number == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(<span class="string">&quot;Block number must not be nil.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	bnum, err := strconv.ParseUint(<span class="keyword">string</span>(number), <span class="number">10</span>, <span class="number">64</span>) <span class="comment">// 转换成uint型</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;Failed to parse block number with error %s&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	block, err := vledger.GetBlockByNumber(bnum) <span class="comment">// 调用账本中的方法</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;Failed to get block number %d, error %s&quot;</span>, bnum, err))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> consider trim block content before returning</span></span><br><span class="line">	<span class="comment">//  Specifically, trim transaction &#x27;data&#x27; out of the transaction array Payloads</span></span><br><span class="line">	<span class="comment">//  This will preserve the transaction Payload header,</span></span><br><span class="line">	<span class="comment">//  and client can do GetTransactionByID() if they want the full transaction details</span></span><br><span class="line"></span><br><span class="line">    bytes, err := protoutil.Marshal(block) </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> shim.Success(bytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBlockByHash</span><span class="params">(vledger ledger.PeerLedger, hash []<span class="keyword">byte</span>)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> hash == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(<span class="string">&quot;Block hash must not be nil.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	block, err := vledger.GetBlockByHash(hash)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;Failed to get block hash %s, error %s&quot;</span>, <span class="keyword">string</span>(hash), err))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> consider trim block content before returning</span></span><br><span class="line">	<span class="comment">//  Specifically, trim transaction &#x27;data&#x27; out of the transaction array Payloads</span></span><br><span class="line">	<span class="comment">//  This will preserve the transaction Payload header,</span></span><br><span class="line">	<span class="comment">//  and client can do GetTransactionByID() if they want the full transaction details</span></span><br><span class="line"></span><br><span class="line">	bytes, err := protoutil.Marshal(block)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> shim.Success(bytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getChainInfo</span><span class="params">(vledger ledger.PeerLedger)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">	binfo, err := vledger.GetBlockchainInfo()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;Failed to get block info with error %s&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	bytes, err := protoutil.Marshal(binfo)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> shim.Success(bytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBlockByTxID</span><span class="params">(vledger ledger.PeerLedger, rawTxID []<span class="keyword">byte</span>)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">	txID := <span class="keyword">string</span>(rawTxID)</span><br><span class="line">	block, err := vledger.GetBlockByTxID(txID)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;Failed to get block for txID %s, error %s&quot;</span>, txID, err))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bytes, err := protoutil.Marshal(block)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> shim.Success(bytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getACLResource</span><span class="params">(fname <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;qscc/&quot;</span> + fname</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Endorser-System-Chaincode-ESCC"><a href="#Endorser-System-Chaincode-ESCC" class="headerlink" title="Endorser System Chaincode (ESCC)"></a>Endorser System Chaincode (ESCC)</h1><h1 id="Validator-System-Chaincode-VSCC"><a href="#Validator-System-Chaincode-VSCC" class="headerlink" title="Validator System Chaincode (VSCC)"></a>Validator System Chaincode (VSCC)</h1><blockquote>
<p>/core/committer/txvalidator/v14/vscc_validator.go</p>
</blockquote>
<p>验证事务的有效性和背书的正确性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> txvalidator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/golang/protobuf/proto&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric-protos-go/common&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric-protos-go/peer&quot;</span></span><br><span class="line">	commonerrors <span class="string">&quot;github.com/hyperledger/fabric/common/errors&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric/common/policydsl&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric/core/common/ccprovider&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric/core/common/sysccprovider&quot;</span></span><br><span class="line">	validation <span class="string">&quot;github.com/hyperledger/fabric/core/handlers/validation/api&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/rwsetutil&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric/protoutil&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/pkg/errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// VsccValidatorImpl is the implementation used to call</span></span><br><span class="line"><span class="comment">// the vscc chaincode and validate block transactions</span></span><br><span class="line"><span class="keyword">type</span> VsccValidatorImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">	channelID       <span class="keyword">string</span></span><br><span class="line">	cr              ChannelResources</span><br><span class="line">	pluginValidator *PluginValidator</span><br><span class="line">&#125; <span class="comment">// 用于调用vscc链码并验证区块事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// newVSCCValidator creates new vscc validator</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newVSCCValidator</span><span class="params">(channelID <span class="keyword">string</span>, cr ChannelResources, pluginValidator *PluginValidator)</span> *<span class="title">VsccValidatorImpl</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;VsccValidatorImpl&#123;</span><br><span class="line">		channelID:       channelID,</span><br><span class="line">		cr:              cr,</span><br><span class="line">		pluginValidator: pluginValidator,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getChaincodeHeaderExtension</span><span class="params">(hdr *common.Header)</span> <span class="params">(*peer.ChaincodeHeaderExtension, error)</span></span> &#123;</span><br><span class="line">	chdr, err := protoutil.UnmarshalChannelHeader(hdr.ChannelHeader)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chaincodeHdrExt := &amp;peer.ChaincodeHeaderExtension&#123;&#125;</span><br><span class="line">	err = proto.Unmarshal(chdr.Extension, chaincodeHdrExt)</span><br><span class="line">	<span class="keyword">return</span> chaincodeHdrExt, errors.Wrap(err, <span class="string">&quot;error unmarshaling ChaincodeHeaderExtension&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VSCCValidateTx executes vscc validation for transaction</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">VSCCValidateTx</span><span class="params">(seq <span class="keyword">int</span>, payload *common.Payload, envBytes []<span class="keyword">byte</span>, block *common.Block)</span> <span class="params">(error, peer.TxValidationCode)</span></span> &#123;</span><br><span class="line">	chainID := v.channelID</span><br><span class="line">	logger.Debugf(<span class="string">&quot;[%s] VSCCValidateTx starts for bytes %p&quot;</span>, chainID, envBytes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get header extensions so we have the chaincode ID</span></span><br><span class="line">	hdrExt, err := getChaincodeHeaderExtension(payload.Header)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err, peer.TxValidationCode_BAD_HEADER_EXTENSION</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get channel header</span></span><br><span class="line">	chdr, err := protoutil.UnmarshalChannelHeader(payload.Header.ChannelHeader)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err, peer.TxValidationCode_BAD_CHANNEL_HEADER</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* obtain the list of namespaces we&#x27;re writing stuff to;</span></span><br><span class="line"><span class="comment">	   at first, we establish a few facts about this invocation:</span></span><br><span class="line"><span class="comment">	   1) which namespaces does it write to?</span></span><br><span class="line"><span class="comment">	   2) does it write to LSCC&#x27;s namespace?</span></span><br><span class="line"><span class="comment">	   3) does it write to any cc that cannot be invoked? */</span></span><br><span class="line">	writesToLSCC := <span class="literal">false</span></span><br><span class="line">	writesToNonInvokableSCC := <span class="literal">false</span></span><br><span class="line">	respPayload, err := protoutil.GetActionFromEnvelope(envBytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;GetActionFromEnvelope failed&quot;</span>), peer.TxValidationCode_BAD_RESPONSE_PAYLOAD</span><br><span class="line">	&#125;</span><br><span class="line">	txRWSet := &amp;rwsetutil.TxRwSet&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> err = txRWSet.FromProtoBytes(respPayload.Results); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;txRWSet.FromProtoBytes failed&quot;</span>), peer.TxValidationCode_BAD_RWSET</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Verify the header extension and response payload contain the ChaincodeId</span></span><br><span class="line">	<span class="keyword">if</span> hdrExt.ChaincodeId == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;nil ChaincodeId in header extension&quot;</span>), peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> respPayload.ChaincodeId == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;nil ChaincodeId in ChaincodeAction&quot;</span>), peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get name and version of the cc we invoked</span></span><br><span class="line">	ccID := hdrExt.ChaincodeId.Name</span><br><span class="line">	ccVer := respPayload.ChaincodeId.Version</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sanity check on ccID</span></span><br><span class="line">	<span class="keyword">if</span> ccID == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		err = errors.New(<span class="string">&quot;invalid chaincode ID&quot;</span>)</span><br><span class="line">		logger.Errorf(<span class="string">&quot;%+v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ccID != respPayload.ChaincodeId.Name &#123;</span><br><span class="line">		err = errors.Errorf(<span class="string">&quot;inconsistent ccid info (%s/%s)&quot;</span>, ccID, respPayload.ChaincodeId.Name)</span><br><span class="line">		logger.Errorf(<span class="string">&quot;%+v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// sanity check on ccver</span></span><br><span class="line">	<span class="keyword">if</span> ccVer == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		err = errors.New(<span class="string">&quot;invalid chaincode version&quot;</span>)</span><br><span class="line">		logger.Errorf(<span class="string">&quot;%+v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wrNamespace []<span class="keyword">string</span></span><br><span class="line">	alwaysEnforceOriginalNamespace := v.cr.Capabilities().V1_2Validation()</span><br><span class="line">	<span class="keyword">if</span> alwaysEnforceOriginalNamespace &#123;</span><br><span class="line">		wrNamespace = <span class="built_in">append</span>(wrNamespace, ccID)</span><br><span class="line">		<span class="keyword">if</span> respPayload.Events != <span class="literal">nil</span> &#123;</span><br><span class="line">			ccEvent := &amp;peer.ChaincodeEvent&#123;&#125;</span><br><span class="line">			<span class="keyword">if</span> err = proto.Unmarshal(respPayload.Events, ccEvent); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;invalid chaincode event&quot;</span>), peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ccEvent.ChaincodeId != ccID &#123;</span><br><span class="line">				<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;chaincode event chaincode id does not match chaincode action chaincode id&quot;</span>), peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	namespaces := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> _, ns := <span class="keyword">range</span> txRWSet.NsRwSets &#123;</span><br><span class="line">		<span class="comment">// check to make sure there is no duplicate namespace in txRWSet</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := namespaces[ns.NameSpace]; ok &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;duplicate namespace &#x27;%s&#x27; in txRWSet&quot;</span>, ns.NameSpace),</span><br><span class="line">				peer.TxValidationCode_ILLEGAL_WRITESET</span><br><span class="line">		&#125;</span><br><span class="line">		namespaces[ns.NameSpace] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !v.txWritesToNamespace(ns) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check to make sure we did not already populate this chaincode</span></span><br><span class="line">		<span class="comment">// name to avoid checking the same namespace twice</span></span><br><span class="line">		<span class="keyword">if</span> ns.NameSpace != ccID || !alwaysEnforceOriginalNamespace &#123;</span><br><span class="line">			wrNamespace = <span class="built_in">append</span>(wrNamespace, ns.NameSpace)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !writesToLSCC &amp;&amp; ns.NameSpace == <span class="string">&quot;lscc&quot;</span> &#123;</span><br><span class="line">			writesToLSCC = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !writesToNonInvokableSCC &amp;&amp; IsSysCCAndNotInvokableCC2CC(ns.NameSpace) &#123;</span><br><span class="line">			writesToNonInvokableSCC = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !writesToNonInvokableSCC &amp;&amp; IsSysCCAndNotInvokableExternal(ns.NameSpace) &#123;</span><br><span class="line">			writesToNonInvokableSCC = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we&#x27;ve gathered all the info required to proceed to validation;</span></span><br><span class="line">	<span class="comment">// validation will behave differently depending on the type of</span></span><br><span class="line">	<span class="comment">// chaincode (system vs. application)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !IsSysCC(ccID) &#123;</span><br><span class="line">		<span class="comment">// if we&#x27;re here, we know this is an invocation of an application chaincode;</span></span><br><span class="line">		<span class="comment">// first of all, we make sure that:</span></span><br><span class="line">		<span class="comment">// 1) we don&#x27;t write to LSCC - an application chaincode is free to invoke LSCC</span></span><br><span class="line">		<span class="comment">//    for instance to get information about itself or another chaincode; however</span></span><br><span class="line">		<span class="comment">//    these legitimate invocations only ready from LSCC&#x27;s namespace; currently</span></span><br><span class="line">		<span class="comment">//    only two functions of LSCC write to its namespace: deploy and upgrade and</span></span><br><span class="line">		<span class="comment">//    neither should be used by an application chaincode</span></span><br><span class="line">		<span class="keyword">if</span> writesToLSCC &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;chaincode %s attempted to write to the namespace of LSCC&quot;</span>, ccID),</span><br><span class="line">				peer.TxValidationCode_ILLEGAL_WRITESET</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2) we don&#x27;t write to the namespace of a chaincode that we cannot invoke - if</span></span><br><span class="line">		<span class="comment">//    the chaincode cannot be invoked in the first place, there&#x27;s no legitimate</span></span><br><span class="line">		<span class="comment">//    way in which a transaction has a write set that writes to it; additionally</span></span><br><span class="line">		<span class="comment">//    we don&#x27;t have any means of verifying whether the transaction had the rights</span></span><br><span class="line">		<span class="comment">//    to perform that write operation because in v1, system chaincodes do not have</span></span><br><span class="line">		<span class="comment">//    any endorsement policies to speak of. So if the chaincode can&#x27;t be invoked</span></span><br><span class="line">		<span class="comment">//    it can&#x27;t be written to by an invocation of an application chaincode</span></span><br><span class="line">		<span class="keyword">if</span> writesToNonInvokableSCC &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;chaincode %s attempted to write to the namespace of a system chaincode that cannot be invoked&quot;</span>, ccID),</span><br><span class="line">				peer.TxValidationCode_ILLEGAL_WRITESET</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// validate *EACH* read write set according to its chaincode&#x27;s endorsement policy</span></span><br><span class="line">		<span class="keyword">for</span> _, ns := <span class="keyword">range</span> wrNamespace &#123;</span><br><span class="line">			<span class="comment">// Get latest chaincode version, vscc and validate policy</span></span><br><span class="line">			txcc, vscc, policy, err := v.GetInfoForValidate(chdr, ns)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				logger.Errorf(<span class="string">&quot;GetInfoForValidate for txId = %s returned error: %+v&quot;</span>, chdr.TxId, err)</span><br><span class="line">				<span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// if the namespace corresponds to the cc that was originally</span></span><br><span class="line">			<span class="comment">// invoked, we check that the version of the cc that was</span></span><br><span class="line">			<span class="comment">// invoked corresponds to the version that lscc has returned</span></span><br><span class="line">			<span class="keyword">if</span> ns == ccID &amp;&amp; txcc.ChaincodeVersion != ccVer &#123;</span><br><span class="line">				err = errors.Errorf(<span class="string">&quot;chaincode %s:%s/%s didn&#x27;t match %s:%s/%s in lscc&quot;</span>, ccID, ccVer, chdr.ChannelId, txcc.ChaincodeName, txcc.ChaincodeVersion, chdr.ChannelId)</span><br><span class="line">				logger.Errorf(<span class="string">&quot;%+v&quot;</span>, err)</span><br><span class="line">				<span class="keyword">return</span> err, peer.TxValidationCode_EXPIRED_CHAINCODE</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// do VSCC validation</span></span><br><span class="line">			ctx := &amp;Context&#123;</span><br><span class="line">				Seq:       seq,</span><br><span class="line">				Envelope:  envBytes,</span><br><span class="line">				Block:     block,</span><br><span class="line">				TxID:      chdr.TxId,</span><br><span class="line">				Channel:   chdr.ChannelId,</span><br><span class="line">				Namespace: ns,</span><br><span class="line">				Policy:    policy,</span><br><span class="line">				VSCCName:  vscc.ChaincodeName,</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err = v.VSCCValidateTxForCC(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">				<span class="keyword">case</span> *commonerrors.VSCCEndorsementPolicyError:</span><br><span class="line">					<span class="keyword">return</span> err, peer.TxValidationCode_ENDORSEMENT_POLICY_FAILURE</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// make sure that we can invoke this system chaincode - if the chaincode</span></span><br><span class="line">		<span class="comment">// cannot be invoked through a proposal to this peer, we have to drop the</span></span><br><span class="line">		<span class="comment">// transaction; if we didn&#x27;t, we wouldn&#x27;t know how to decide whether it&#x27;s</span></span><br><span class="line">		<span class="comment">// valid or not because in v1, system chaincodes have no endorsement policy</span></span><br><span class="line">		<span class="keyword">if</span> IsSysCCAndNotInvokableExternal(ccID) &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;committing an invocation of cc %s is illegal&quot;</span>, ccID),</span><br><span class="line">				peer.TxValidationCode_ILLEGAL_WRITESET</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get latest chaincode version, vscc and validate policy</span></span><br><span class="line">		_, vscc, policy, err := v.GetInfoForValidate(chdr, ccID)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.Errorf(<span class="string">&quot;GetInfoForValidate for txId = %s returned error: %+v&quot;</span>, chdr.TxId, err)</span><br><span class="line">			<span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// validate the transaction as an invocation of this system chaincode;</span></span><br><span class="line">		<span class="comment">// vscc will have to do custom validation for this system chaincode</span></span><br><span class="line">		<span class="comment">// currently, VSCC does custom validation for LSCC only; if an hlf</span></span><br><span class="line">		<span class="comment">// user creates a new system chaincode which is invokable from the outside</span></span><br><span class="line">		<span class="comment">// they have to modify VSCC to provide appropriate validation</span></span><br><span class="line">		ctx := &amp;Context&#123;</span><br><span class="line">			Seq:       seq,</span><br><span class="line">			Envelope:  envBytes,</span><br><span class="line">			Block:     block,</span><br><span class="line">			TxID:      chdr.TxId,</span><br><span class="line">			Channel:   chdr.ChannelId,</span><br><span class="line">			Namespace: ccID,</span><br><span class="line">			Policy:    policy,</span><br><span class="line">			VSCCName:  vscc.ChaincodeName,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err = v.VSCCValidateTxForCC(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *commonerrors.VSCCEndorsementPolicyError:</span><br><span class="line">				<span class="keyword">return</span> err, peer.TxValidationCode_ENDORSEMENT_POLICY_FAILURE</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	logger.Debugf(<span class="string">&quot;[%s] VSCCValidateTx completes env bytes %p&quot;</span>, chainID, envBytes)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, peer.TxValidationCode_VALID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">VSCCValidateTxForCC</span><span class="params">(ctx *Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	logger.Debug(<span class="string">&quot;Validating&quot;</span>, ctx, <span class="string">&quot;with plugin&quot;</span>)</span><br><span class="line">	err := v.pluginValidator.ValidateWithPlugin(ctx)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If the error is a pluggable validation execution error, cast it to the common errors ExecutionFailureError.</span></span><br><span class="line">	<span class="keyword">if</span> e, isExecutionError := err.(*validation.ExecutionFailureError); isExecutionError &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;commonerrors.VSCCExecutionFailureError&#123;Err: e&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Else, treat it as an endorsement error.</span></span><br><span class="line">	<span class="keyword">return</span> &amp;commonerrors.VSCCEndorsementPolicyError&#123;Err: err&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">getCDataForCC</span><span class="params">(chid, ccid <span class="keyword">string</span>)</span> <span class="params">(*ccprovider.ChaincodeData, error)</span></span> &#123;</span><br><span class="line">	l := v.cr.Ledger()</span><br><span class="line">	<span class="keyword">if</span> l == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;nil ledger instance&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	qe, err := l.NewQueryExecutor()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">&quot;could not retrieve QueryExecutor&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> qe.Done()</span><br><span class="line"></span><br><span class="line">	bytes, err := qe.GetState(<span class="string">&quot;lscc&quot;</span>, ccid)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, &amp;commonerrors.VSCCInfoLookupFailureError&#123;</span><br><span class="line">			Reason: fmt.Sprintf(<span class="string">&quot;Could not retrieve state for chaincode %s, error %s&quot;</span>, ccid, err),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> bytes == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;lscc&#x27;s state for [%s] not found.&quot;</span>, ccid)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cd := &amp;ccprovider.ChaincodeData&#123;&#125;</span><br><span class="line">	err = proto.Unmarshal(bytes, cd)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;unmarshalling ChaincodeQueryResponse failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cd.Vscc == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;lscc&#x27;s state for [%s] is invalid, vscc field must be set&quot;</span>, ccid)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(cd.Policy) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;lscc&#x27;s state for [%s] is invalid, policy field must be set&quot;</span>, ccid)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cd, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetInfoForValidate gets the ChaincodeInstance(with latest version) of tx, vscc and policy from lscc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">GetInfoForValidate</span><span class="params">(chdr *common.ChannelHeader, ccID <span class="keyword">string</span>)</span> <span class="params">(*sysccprovider.ChaincodeInstance, *sysccprovider.ChaincodeInstance, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	cc := &amp;sysccprovider.ChaincodeInstance&#123;</span><br><span class="line">		ChannelID:     chdr.ChannelId,</span><br><span class="line">		ChaincodeName: ccID,</span><br><span class="line">	&#125;</span><br><span class="line">	vscc := &amp;sysccprovider.ChaincodeInstance&#123;</span><br><span class="line">		ChannelID:     chdr.ChannelId,</span><br><span class="line">		ChaincodeName: <span class="string">&quot;vscc&quot;</span>, <span class="comment">// default vscc for system chaincodes</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> policy []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">if</span> !IsSysCC(ccID) &#123;</span><br><span class="line">		<span class="comment">// when we are validating a chaincode that is not a</span></span><br><span class="line">		<span class="comment">// system CC, we need to ask the CC to give us the name</span></span><br><span class="line">		<span class="comment">// of VSCC and of the policy that should be used</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// obtain name of the VSCC and the policy</span></span><br><span class="line">		cd, err := v.getCDataForCC(chdr.ChannelId, ccID)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			msg := fmt.Sprintf(<span class="string">&quot;Unable to get chaincode data from ledger for txid %s, due to %s&quot;</span>, chdr.TxId, err)</span><br><span class="line">			logger.Errorf(msg)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		cc.ChaincodeName = cd.Name</span><br><span class="line">		cc.ChaincodeVersion = cd.Version</span><br><span class="line">		vscc.ChaincodeName, policy = cd.Vscc, cd.Policy</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// when we are validating a system CC, we use the default</span></span><br><span class="line">		<span class="comment">// VSCC and a default policy that requires one signature</span></span><br><span class="line">		<span class="comment">// from any of the members of the channel</span></span><br><span class="line">		p := policydsl.SignedByAnyMember(v.cr.GetMSPIDs())</span><br><span class="line">		policy, err = protoutil.Marshal(p)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cc, vscc, policy, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// txWritesToNamespace returns true if the supplied NsRwSet</span></span><br><span class="line"><span class="comment">// performs a ledger write</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">txWritesToNamespace</span><span class="params">(ns *rwsetutil.NsRwSet)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// check for public writes first</span></span><br><span class="line">	<span class="keyword">if</span> ns.KvRwSet != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(ns.KvRwSet.Writes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// only look at collection data if we support that capability</span></span><br><span class="line">	<span class="keyword">if</span> v.cr.Capabilities().PrivateChannelData() &#123;</span><br><span class="line">		<span class="comment">// check for private writes for all collections</span></span><br><span class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> ns.CollHashedRwSets &#123;</span><br><span class="line">			<span class="keyword">if</span> c.HashedRwSet != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(c.HashedRwSet.HashedWrites) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// only look at private metadata writes if we support that capability</span></span><br><span class="line">			<span class="keyword">if</span> v.cr.Capabilities().KeyLevelEndorsement() &#123;</span><br><span class="line">				<span class="comment">// private metadata updates</span></span><br><span class="line">				<span class="keyword">if</span> c.HashedRwSet != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(c.HashedRwSet.MetadataWrites) &gt; <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// only look at metadata writes if we support that capability</span></span><br><span class="line">	<span class="keyword">if</span> v.cr.Capabilities().KeyLevelEndorsement() &#123;</span><br><span class="line">		<span class="comment">// public metadata updates</span></span><br><span class="line">		<span class="keyword">if</span> ns.KvRwSet != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(ns.KvRwSet.MetadataWrites) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSysCCAndNotInvokableExternal</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> name == <span class="string">&quot;vscc&quot;</span> || name == <span class="string">&quot;escc&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSysCC</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> name == <span class="string">&quot;vscc&quot;</span> || name == <span class="string">&quot;escc&quot;</span> || name == <span class="string">&quot;lscc&quot;</span> || name == <span class="string">&quot;qscc&quot;</span> || name == <span class="string">&quot;cscc&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSysCCAndNotInvokableCC2CC</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> name == <span class="string">&quot;vscc&quot;</span> || name == <span class="string">&quot;escc&quot;</span> || name == <span class="string">&quot;cscc&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>fabric</tag>
        <tag>go</tag>
      </tags>
  </entry>
</search>
