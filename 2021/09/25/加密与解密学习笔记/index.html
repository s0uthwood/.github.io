<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|console:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"s0uthwood.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="suibiankankan">
<meta property="og:type" content="article">
<meta property="og:title" content="加密与解密学习笔记（持续更新ing）">
<meta property="og:url" content="https://s0uthwood.github.io/2021/09/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="s0uthwood&#39;s Blog">
<meta property="og:description" content="suibiankankan">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-09-24T18:15:45.000Z">
<meta property="article:modified_time" content="2021-09-25T18:18:33.280Z">
<meta property="article:author" content="s0uthwood">
<meta property="article:tag" content="Reverse">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://s0uthwood.github.io/2021/09/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>加密与解密学习笔记（持续更新ing） | s0uthwood's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="s0uthwood's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">s0uthwood's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s0uthwood.github.io/2021/09/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar3.jpg">
      <meta itemprop="name" content="s0uthwood">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0uthwood's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          加密与解密学习笔记（持续更新ing）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-25 02:15:45" itemprop="dateCreated datePublished" datetime="2021-09-25T02:15:45+08:00">2021-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-26 02:18:33" itemprop="dateModified" datetime="2021-09-26T02:18:33+08:00">2021-09-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/Reverse/" itemprop="url" rel="index"><span itemprop="name">Reverse</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>suibiankankan</p>
<a id="more"></a>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="分析的一般途径和策略"><a href="#分析的一般途径和策略" class="headerlink" title="分析的一般途径和策略"></a>分析的一般途径和策略</h2><ol>
<li>学会软件的操作和使用方法 $\to$ 推测出软件的设计思想和编程思路</li>
<li>静态分析：阅读反汇编的程序清单，利用人机交互的提示信息了解片段所完成的功能，宏观了解软件的编程思路</li>
<li>动态跟踪：首先完成反反调试，并解密加密程序，了解初始化工作，获得各个模块之间的中间结果<ol>
<li>粗跟踪：不跟踪调用等指令，仅根据执行结果分析程序的功能</li>
<li>细跟踪：针对性跟踪分析关键模块</li>
</ol>
</li>
</ol>
<h2 id="文本字符"><a href="#文本字符" class="headerlink" title="文本字符"></a>文本字符</h2><h3 id="ASCII-和-Unicode"><a href="#ASCII-和-Unicode" class="headerlink" title="ASCII 和 Unicode"></a>ASCII 和 Unicode</h3><p>Unicode 是 ASCII 的扩展，所有字符都是 16 位</p>
<h3 id="字节存储顺序"><a href="#字节存储顺序" class="headerlink" title="字节存储顺序"></a>字节存储顺序</h3><p>小端序（Little-endian）：高位字节存入高地址，低位字节存入低地址</p>
<p>大端序（Big-endian）：高位字节存入低地址，低位字节存入高地址</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字节序</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>大端序</td>
<td>12</td>
<td>34</td>
<td>56</td>
<td>78</td>
</tr>
<tr>
<td>小端序</td>
<td>78</td>
<td>56</td>
<td>34</td>
<td>12</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="Win-32-API"><a href="#Win-32-API" class="headerlink" title="Win 32 API"></a>Win 32 API</h3><p>32位API与64位API在名称和功能上基本没有变化</p>
<p>Windows运转核心为DLL动态链接库</p>
<ul>
<li>KERNEL32.DLL：操作系统核心功能服务，进程与线程控制、内存管理、文件访问等</li>
<li>USER32.DLL：负责处理用户接口，包括键盘和鼠标输入、窗口和菜单管理等</li>
<li>GDI：图形设备接口，允许程序在屏幕和打印机上显示文本和图形</li>
</ul>
<h3 id="Windows消息机制"><a href="#Windows消息机制" class="headerlink" title="Windows消息机制"></a>Windows消息机制</h3><p>Windows使用Message提供应用程序与应用程序、应用程序与操作系统之间的通信</p>
<p>常用的函数如下：</p>
<h4 id="SendMessage"><a href="#SendMessage" class="headerlink" title="SendMessage"></a>SendMessage</h4><p>调用一个窗口的窗口函数，将一条消息发送给那个窗口。除非消息处理完毕，否则不会返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">SendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HWND hwnd,			<span class="comment">// 目的窗口的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">	UINT Msg,			<span class="comment">// 消息标识符</span></span></span></span><br><span class="line"><span class="function"><span class="params">	WPARAM wParam,		<span class="comment">// 消息的WPARAM域</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPARAM lParam		<span class="comment">// 消息的LPARAM域</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong>：消息投递成功，返回非零</p>
<h4 id="WM-COMMAND"><a href="#WM-COMMAND" class="headerlink" title="WM_COMMAND"></a>WM_COMMAND</h4><p>当用户从菜单或按钮中选择一条命令或者一个控件时该消息被发送给它的父窗口，或者当一个快捷键被释放时发送该消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WM_COMMAND</span><br><span class="line">	wNotifyCode = HIWORD(wParam);		 <span class="comment">// 通告函数</span></span><br><span class="line">	wID = LOWORD(wParam);				<span class="comment">// 菜单条目、控件或快捷键的标识符</span></span><br><span class="line">	hwndCtl = (HWND) lParam;			<span class="comment">// 控件句柄</span></span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong>：如果应用程序处理这条消息，则返回值为零</p>
<h4 id="WM-DESTORY"><a href="#WM-DESTORY" class="headerlink" title="WM_DESTORY"></a>WM_DESTORY</h4><p>当一个窗口被销毁时发送该消息。该消息对应 <code>0x02</code>，没有参数</p>
<p><strong>返回值</strong>：如果应用程序处理这条消息，则返回值为零</p>
<h4 id="WM-GETTEXT"><a href="#WM-GETTEXT" class="headerlink" title="WM_GETTEXT"></a>WM_GETTEXT</h4><p>当需要将一个窗口的文本复制到一个由呼叫程序提供的缓冲区中时，发送该消息。该消息对应 <code>0x0D</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WM_GETTEXT</span><br><span class="line">	wParam = (WPARAM) cchTextMax;	<span class="comment">// 需要复制的字符数</span></span><br><span class="line">	lParam = (LPARAM) lpszText;		<span class="comment">// 接收文本的缓冲区地址</span></span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong>：被复制的字符数</p>
<h4 id="WM-QUIT"><a href="#WM-QUIT" class="headerlink" title="WM_QUIT"></a>WM_QUIT</h4><p>当应用程序调用 <code>PostQuitMessage</code> 时，生成 <code>WM_QUIT</code>消息，对应 <code>0x12</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WM_QUIT</span><br><span class="line">	nExitCode = (<span class="keyword">int</span>) wParam;		<span class="comment">// 退出代码</span></span><br></pre></td></tr></table></figure>
<p>无<strong>返回值</strong></p>
<h4 id="WM-LBUTTONDOWN"><a href="#WM-LBUTTONDOWN" class="headerlink" title="WM_LBUTTONDOWN"></a>WM_LBUTTONDOWN</h4><p>光标停在窗口客户区且点击左键时，发送此消息</p>
<p>如果鼠标未捕捉，将下发给光标下的窗口，否则发送给捕获鼠标动作的窗口</p>
<p>对应 <code>0x201</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WM_LBUTTONDOWN</span><br><span class="line">	fwkeys = wParam;			<span class="comment">// key旗帜</span></span><br><span class="line">	xPos = LOWORD(lParam);		<span class="comment">// 光标的水平位置</span></span><br><span class="line">	yPos = HIWORD(lParam);		<span class="comment">// 光标的垂直位置</span></span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong>：如果应用程序处理了这条消息，返回值为零</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul>
<li>应用程序不会直接访问物理地址</li>
<li>虚拟内存管理器通过虚拟地址的访问请求来控制所有的物理地址访问</li>
<li>每个应用都有独立的寻址空间，不同应用程序的地址空间是彼此隔离的</li>
<li>DLL程序没有私有空间，总是被映射到其他应用程序的地址空间中，作为程序的一部分运行</li>
</ul>
<h1 id="动态分析技术"><a href="#动态分析技术" class="headerlink" title="动态分析技术"></a>动态分析技术</h1><h1 id="逆向分析技术"><a href="#逆向分析技术" class="headerlink" title="逆向分析技术"></a>逆向分析技术</h1><h2 id="Win32"><a href="#Win32" class="headerlink" title="Win32"></a>Win32</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>程序先执行启动代码，随后调用 <code>WinMain</code> 函数</p>
<p>实例中的系统调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Call KERNEL32.GetVersion              ; 确定Windows系统版本</span><br><span class="line">Call KERNEL32.GetCommandLineA         ; 指向系统的完整命令行的指针</span><br><span class="line">Call KERNEL32.GetStartupInfoA         ; 获取一个进程的启动信息</span><br><span class="line">Call KERNEL32.GetModuleHandleA        ; 返回进程地址空间执行文件基地址</span><br><span class="line">call 00401000                         ; 调用WinMain</span><br><span class="line">call 004012EC                         ; 退出程序</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常无需关注启动，直接查看 <code>WinMain</code> 即可</p>
</blockquote>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>编译器通常使用 <code>call</code> 和 <code>ret</code> 指令来调用函数</p>
<p><code>call</code> 指令将其之后的指令地址压入栈顶，<code>ret</code> 指令则返回到调用位置</p>
<p>有时可能利用寄存器进行间接调用，如： <code>call eax</code> </p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>调用函数时，将参数压入栈中</p>
<p>对于不同语言，有不同的调用约定</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>C/C++(__cdecl)</th>
<th>pascal</th>
<th>stdcall</th>
<th>fastcall</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数传递顺序</td>
<td>从右向左</td>
<td>从左向右</td>
<td>从右向左</td>
<td>使用寄存器和栈</td>
</tr>
<tr>
<td>平衡栈</td>
<td>调用者</td>
<td>子程序</td>
<td>子程序</td>
<td>子程序</td>
</tr>
<tr>
<td>VARARG</td>
<td>是</td>
<td>否</td>
<td>允许*</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>VARARG表示参数个数可以不确定</p>
<p>stdcall中，如果参数个数不确定，需要由调用程序来平衡栈</p>
</blockquote>
<p>程序执行过程：</p>
<ul>
<li>调用者将函数执行完毕时应返回的地址、参数压入栈</li>
<li>函数使用 <code>ebp</code> 指针+偏移量对栈中的参数进行寻址并取出，完成操作</li>
<li>子程序使用 <code>ret</code> 或 <code>retf</code> 指令返回， <code>eip</code> 置为栈中保存的地址，并继续执行</li>
</ul>
<p>栈的建立过程（两个参数时）：</p>
<ul>
<li>先将 <code>arg2</code> 压栈，<code>esp=K-04h</code></li>
<li>将 <code>arg1</code> 压栈，<code>esp=K-08h</code> </li>
<li>执行 <code>call</code> ，把返回地址压栈，<code>esp=K-0Ch</code></li>
<li>为了程序能够恢复，将 <code>ebp</code> 压栈，<code>esp=K-10h</code></li>
<li><code>move ebp, esp</code>，将当前的栈顶设置为栈底</li>
<li><code>sub esp, 8</code> ，定义局部变量，两个变量分别为 <code>[esp-4]</code> 和 <code>[esp-8]</code></li>
<li>函数结束时，<code>add esp, 8</code> 释放局部变量占用，或者使用 <code>ret 8</code> 来释放</li>
</ul>
<blockquote>
<p>还可以用enter和leave指令维护</p>
<p><code>enter</code> 指令：<code>push ebp</code>，<code>mov ebp, esp</code>，<code>sub esp, xxx</code></p>
<p><code>leave</code> 指令：<code>add esp, xxx</code>，<code>pop ebp</code></p>
</blockquote>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>通常遵循 <code>fastcall</code> 规范</p>
<ul>
<li>VC++：左边两个参数分别存入 <code>ecx</code>, <code>edx</code> 中，其余压栈</li>
<li>Borland Delphi/C++：左边三个参数分别存入 <code>eax</code>, <code>edx</code>, <code>ecx</code> 中，其余按PASCAL方式压栈</li>
</ul>
<p>C++非静态类成员默认调用 <code>thiscall</code> ，对象的每个函数隐含接受 <code>this</code> 参数，使用 <code>eax</code> 存放，其余参数从右到左压栈</p>
<h4 id="名称修饰约定"><a href="#名称修饰约定" class="headerlink" title="名称修饰约定"></a>名称修饰约定</h4><p>为了操作符和函数重载，C++编译器会按照规则修改入口点的符号名，从而允许同一个名字有多个用法。</p>
<p>C的规则如下：</p>
<ul>
<li>stdcall调用约定在输出函数名前加下划线，在后面加@，格式为 <code>_functionname@number</code></li>
<li>__cdecl调用约定格式为 <code>_functionname</code></li>
<li>Fastcall调用约定格式位 <code>@functionname@number</code></li>
</ul>
<p>均不改变大小写</p>
<p>C++规则如下：</p>
<ul>
<li>stdcall调用约定以 <code>?</code> 开头，函数名后以 <code>@@YG</code> 标识参数表开始，后跟参数表，参数表第一项位返回值类型，其后依次为参数的数据类型，指针标识在其所指数据类型前，参数表后，以 <code>@Z</code> 标识整个名字的结束，若无参数，则以 <code>Z</code> 结束。格式为 <code>?functionname@@YG******@Z</code> 或 <code>?functionname@@YG*XZ</code></li>
<li>__cdecl调用将 <code>@@YG</code> 替换为 <code>@@YA</code></li>
<li>Fastcall调用将 <code>@@YG</code> 替换为 <code>@@YI</code></li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><h4 id="return操作返回"><a href="#return操作返回" class="headerlink" title="return操作返回"></a>return操作返回</h4><p>存放在 <code>eax</code> 寄存器中，高32位存放在 <code>edx</code> 中</p>
<h4 id="传引用方式返回"><a href="#传引用方式返回" class="headerlink" title="传引用方式返回"></a>传引用方式返回</h4><p>传引用调用方式将变量的地址传递给函数，可以在子函数中修改该内存单元中变量的值，因此允许修改原始变量</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>函数内部定义的一个变量，作用域和生命周期仅局限于该函数内</p>
<h5 id="栈存放"><a href="#栈存放" class="headerlink" title="栈存放"></a>栈存放</h5><p>先将参数压入栈中，再修改 <code>ebp</code> ，最后减小 <code>esp</code>。因此 <code>[ebp+**h]</code> 表示参数， <code>[ebp-**h]</code> 表示局部变量</p>
<h5 id="寄存器存放"><a href="#寄存器存放" class="headerlink" title="寄存器存放"></a>寄存器存放</h5><p>有 6 个通用寄存器尽可能有效地存放局部变量， 因此需要注意确定当前的寄存器中存储的变量是哪个变量</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>局部变量存放在栈中，而全局变量存放在内存区中</p>
<p>版本标记等常数通常为全局变量</p>
<p>全局变量通常存放在数据区块 <code>.data</code> 的一个固定地址处，程序使用固定的硬编码地址进行寻址</p>
<p>如果在只读区块，说明是一个常量</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>一般通过基址+变址实现寻址，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [407030h + eax]</span><br></pre></td></tr></table></figure>
<p>间接寻址一般用于给数组和结构赋值，<code>[base+n]</code> 根据n的不同对结构中的相应单元赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0040101D lea esi, dword ptr [esp+8]</span><br><span class="line">00401021 mov edi, 3</span><br><span class="line">00401026 mov eas, dword ptr [esi]</span><br><span class="line">...</span><br><span class="line">00401036 add esi, 4</span><br><span class="line">00401039 dec edi</span><br><span class="line">0040103A jnz short 00401026</span><br></pre></td></tr></table></figure>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><blockquote>
<p>C++面向对象中，最重要的概念就是虚函数</p>
</blockquote>
<p>虚函数是程序运行时定义的函数，其地址不能在编译时确定，只能在调用即将进行时确定。虚函数的引用存放在专用数组——虚函数表（Virtual Table，VTBL）中。</p>
<p>调用时首先通过虚函数指针找到虚函数表的地址，然后在虚函数表中找到该函数的入口地址，最后进行调用。</p>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h4><p>汇编形式通常为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp a, bjz  0040xxxxh  ; (jnz)</span><br></pre></td></tr></table></figure>
<p>可以用 <code>test eax, eax</code> 替代 <code>cmp</code> ，该语句（相当于逻辑与运算）表示当 <code>eax</code> 为 0 时，设置 <code>ZF</code> 为 1，<code>jz</code> 则表示 <code>ZF</code> 位为 1 时跳转</p>
<h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h4><p>无优化版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040101D cmp [ebp-08], 01    ; case 100401021 je  0040103100401023 cmp [ebp-08], 02    ; case 200401027 je  0040104000401029 cmp [ebp-08], 0A    ; case 100040102D je  0040104F0040102F jmp 0040105E        ; default</span><br></pre></td></tr></table></figure>
<p>使用 <code>dec</code> 指令替代 <code>cmp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [esp+08]dec eax             ; case 1je  0040xxxxdec eax             ; case 2je  0040xxxxsub eax, 00000008   ; case 10je  0040xxxx</span><br></pre></td></tr></table></figure>
<p>跳转表实现（case的取值为算术级数时）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp dword ptr [4*eax+004010B0]   ; 跳转表</span><br></pre></td></tr></table></figure>
<h4 id="转移指令机器码计算"><a href="#转移指令机器码计算" class="headerlink" title="转移指令机器码计算"></a>转移指令机器码计算</h4><p>位移量=目的地址-起始地址-跳转指令长度</p>
<p>转移指令机器码=转移类别机器码+位移量</p>
<p>转移指令可以分为短转移，长转移和子程序调用（call）</p>
<p>短转移2字节</p>
<p>长转移无条件5字节，条件转移6字节</p>
<p>call指令5字节</p>
<h4 id="条件设置指令"><a href="#条件设置指令" class="headerlink" title="条件设置指令"></a>条件设置指令</h4><p>对于语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = (a &lt; b) ? c1 : c2;</span><br></pre></td></tr></table></figure>
<p>条件分支语句为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp a, b  mov eax, c1  jl  L1  mov eax, c2L1:</span><br></pre></td></tr></table></figure>
<p>使用条件设置语句可以不包含条件分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xor   eax, eaxcmp   a, bsetge al       ; if a &gt;&#x3D; b, al &#x3D; 1, else al &#x3D; 0dec   eaxand   eax, (c1 - c2)add   eax, c2</span><br></pre></td></tr></table></figure>
<p>或者使用条件传输指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov   eax, c2cmp   a, bcmovl eax, cl</span><br></pre></td></tr></table></figure>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>通常使用 <code>ecx</code> 寄存器作为计数器，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xor ecx, ecx ; 计数器清空:L1	inc ecx	...	cmp ecx, 05  ; 循环退出条件	jbe L1</span><br></pre></td></tr></table></figure>
<p>优化后的循环实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xor ecx, ecx    xor eax, eax:L1    add ecx, eax    inc eax    cmp eax, 64h    jle L1    xor eax, eax</span><br></pre></td></tr></table></figure>
<p>对应的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)    sum += i;</span><br></pre></td></tr></table></figure>
<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><h4 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h4><p><code>add</code> 和 <code>sub</code> 指令，有时候可以使用 <code>lea</code> 进行优化</p>
<p>lea 允许一个时钟内计算 <code>lea edx, [eax+ecx+78h]</code> 级别的运算</p>
<h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p>乘法使用 <code>mul</code> 或 <code>imul</code> 指令</p>
<p>对于2的幂，使用 <code>shl</code> 指令可以加快运算</p>
<p>由于 <code>lea</code> 指令可以实现乘 2, 4, 8 的运算，因此可以用来加快 3, 5, 6, 7, 9 等数字的乘法运算，如 <code>lea eax, [eax+eax*4]</code></p>
<h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p><code>div</code> 或 <code>idiv</code> 指令</p>
<p>对于2的幂，使用 <code>shr</code> 指令加速，有符号时使用 <code>sar</code></p>
<p>此外可以利用乘法进行加速</p>
<p>常见的优化公式为</p>
<script type="math/tex; mode=display">
\dfrac{a}{b}=a\times \dfrac{1}{b}</script><p>因此，$\div 11$ 可以优化为 $(\times 2E8BA2E9)&gt;&gt;(32+1)$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov  eax, 2E8BA2E9imul ecxsar  edx, 1          ; edx中存放了乘法的高位双字节mov  ecx, edx</span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="字符串存储"><a href="#字符串存储" class="headerlink" title="字符串存储"></a>字符串存储</h4><p>分为两种，一种使用结束符作为标识，一种记录长度</p>
<ul>
<li>C语言：<code>String\0</code></li>
<li>DOS字符串：<code>String$</code></li>
<li>PASCAL：<code>\x05String</code></li>
<li>Delphi：<code>\x05\x00String</code></li>
</ul>
<p>Go语言使用一个64位整型记录长度</p>
<h4 id="字符寻址指令"><a href="#字符寻址指令" class="headerlink" title="字符寻址指令"></a>字符寻址指令</h4><p>mov将当前指令所在的内存复制并放到目的寄存器中，可操作常量或指针</p>
<p>lea是装入有效地址，操作数是地址</p>
<p>以下两条指令是等价的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea eax, [401000h]mov eax, 401000h</span><br></pre></td></tr></table></figure>
<p>都是将401000h写入eax寄存器中</p>
<p>因此，以下两个指令也是等价的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea eax, [eax+8]add eax, 8</span><br></pre></td></tr></table></figure>
<p>常被编译器用来计算加法</p>
<h4 id="ASCII大小写转换"><a href="#ASCII大小写转换" class="headerlink" title="ASCII大小写转换"></a>ASCII大小写转换</h4><p>区别在于二进制的第五位，大写字母为0，小写字母为1</p>
<p>因此有如下方法</p>
<ul>
<li>大小写转换：$\pm\ \mathrm{0x}20$，$\oplus\ \mathrm{0x}20$</li>
<li>转大写：$\&amp;\ \mathrm{0b}11011111$</li>
<li>转小写：$|\ \mathrm{0b}00100000$</li>
</ul>
<h4 id="计算长度"><a href="#计算长度" class="headerlink" title="计算长度"></a>计算长度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ecx, FFFFFFFF  ; 这一句是一个重要特征xor eax, eax       ; 清零，原文为subrepnz              ; 复制串操作，直到ecx为0scasb              ; 串扫描指令，把al中的内容与edi指向的附加段中的数据逐一比较not ecx            ; ecx&#x3D;字符长度+1dec ecx            ; ecx&#x3D;字符长度je xxxxxx          ; 如果ecx为0，说明长度为0</span><br></pre></td></tr></table></figure>
<h3 id="指令修改技巧"><a href="#指令修改技巧" class="headerlink" title="指令修改技巧"></a>指令修改技巧</h3><p>eax有优化，尽可能使用</p>
<p>替换字节：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>机器码</th>
<th>指令字节长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>nop</td>
<td>90</td>
<td>1</td>
</tr>
<tr>
<td>push eax + pop eax</td>
<td>50 58</td>
<td>2</td>
</tr>
<tr>
<td>inc eax + dec eax</td>
<td>40 48</td>
<td>2</td>
</tr>
<tr>
<td>mov edi, edi</td>
<td>8B FF</td>
<td>2</td>
</tr>
<tr>
<td>jmp xx</td>
<td>EB 00</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>用nop就行</p>
<p>寄存器清零：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>机器码</th>
<th>指令字节长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov eax, 00000000h</td>
<td>B8 00 00 00 00</td>
<td>5</td>
</tr>
<tr>
<td>push 0 + pop eax</td>
<td>6A 00 + 58</td>
<td>3</td>
</tr>
<tr>
<td>sub eax, eax</td>
<td>2B C0</td>
<td>2</td>
</tr>
<tr>
<td>xor eax, eax</td>
<td>33 C0</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>测试寄存器是否为0：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>机器码</th>
<th>指令字节长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmp eax, 00000000h</td>
<td>83 F8 00</td>
<td>3</td>
</tr>
<tr>
<td>or eax, eax / test eax, eax</td>
<td>0B C0 / 85 C0</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>后接 <code>je label</code> 字节码为 <code>74 xx</code> 或 <code>0F 84 xxxxxxxx</code>，长度为2或6，取决于近跳转还是远跳转</p>
<p>寄存器置 <code>0FFFFFFFFh</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>机器码</th>
<th>指令字节长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov eax, 0FFFFFFFFh</td>
<td>B8 FF FF FF FF</td>
<td>5</td>
</tr>
<tr>
<td>（清零后）dec eax</td>
<td>48</td>
<td>1</td>
</tr>
<tr>
<td>std + sbb eax, eax</td>
<td>F9 + 2B C0</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<p>转移指令</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>机器码</th>
<th>指令字节长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>jmp label</td>
<td>EB xx / E9 xxxxxxxx</td>
<td>2 / 6</td>
</tr>
<tr>
<td>push label + ret</td>
<td>68 xxxxxxxx + C3</td>
<td>6</td>
</tr>
</tbody>
</table>
</div>
<h2 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h2><p>与32位有很多重叠</p>
<h3 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h3><p>64位通用寄存器 R 开头</p>
<p>8个128位 XMM 寄存器，通常用来优化（SIMD指令）</p>
<p>此外， <code>AX</code> 低16位，<code>AL</code> 低8位， <code>AH</code> 第 $8\sim 15$ 位</p>
<p><code>R8</code> 则有 <code>R8D</code> 低32位，<code>R8W</code> 低16位，<code>R8B</code> 低8位</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h4><p>x64中有如下区别</p>
<ul>
<li><p>一个栈空间8字节（64位）</p>
</li>
<li><p>汇编指令对栈顶需要对齐16（被16整除）</p>
</li>
</ul>
<h4 id="根据start寻找main"><a href="#根据start寻找main" class="headerlink" title="根据start寻找main"></a>根据start寻找main</h4><p>start函数结束前会有如下指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp __tmainCRTStartup</span><br></pre></td></tr></table></figure>
<p>进入该函数后可以看到 <code>main</code> 函数</p>
<p>如果符号表被去除，可根据前后特征进行定位</p>
<blockquote>
<p>在调用完成main后，通常会调用exit来退出进程，所以exit前的一个call就是main函数（也可能在该函数内部的call中）。</p>
</blockquote>
<h4 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h4><p>使用寄存器快速调用约定</p>
<p>前几个参数使用的寄存器是固定的，后续的参数从右往左栈，非1, 2, 4, 8字节大小的参数必须用引用（地址）传参</p>
<p>传递顺序为 <code>RCX</code>， <code>RDX</code>， <code>R8</code>， <code>R9</code>，所有浮点参数由XMM传参，顺序依次为 <code>XMM0</code> ~ <code>XMM3</code></p>
<blockquote>
<p>为了使得寄存器仍然能够使用，会预留栈空间，将寄存器的值存入栈空间中，该空间由调用者申请并平衡</p>
</blockquote>
<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>使用 <code>RAX</code> 返回参数，返回值过大可以使用栈空间作为参数间接访问</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="局部变量-1"><a href="#局部变量-1" class="headerlink" title="局部变量"></a>局部变量</h4><p>使用栈区进行存放</p>
<p>Release版会更多地使用寄存器</p>
<h4 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h4><p>地址通常在编译期固定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, cs:140009150h</span><br></pre></td></tr></table></figure>
<h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><p>$地址=首地址+类型大小\times 下标$</p>
<blockquote>
<p>IDA中使用Y快捷键来修改数据类型，可以反编译成下标模式，更好看一些</p>
</blockquote>
<p>汇编通常为 <code>[地址+寄存器*n]</code>（或者循环中每次循环 <code>地址+=n</code>？）</p>
<h3 id="控制语句-1"><a href="#控制语句-1" class="headerlink" title="控制语句"></a>控制语句</h3><p>通常虚线箭头表示有条件跳转，实线箭头表示无条件跳转</p>
<p>if 语句：jxx跳转，且目的地址后没有jxx（说明不是循环）</p>
<p>if else语句：jxx跳转，且目的地之前有一个jmp实跳转，目的地址后无跳转</p>
<p>if elif else语句：多个jxx跳转，每个Block以jmp结尾，最后一个Block不含跳转</p>
<p>switch case语句：分支数 $\geqslant 6$ 使用case表，$&lt;6$ 使用else if</p>
<blockquote>
<p>无法使用case表的情况下，为减少if的判断次数，可能使用二叉平衡树来减少if判断次数</p>
</blockquote>
<h3 id="循环语句-1"><a href="#循环语句-1" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h4><p>先执行，后判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_while_start:&#123;	; 代码&#125;cmp a, bjxx do_while_start</span><br></pre></td></tr></table></figure>
<p>通常有一个向上跳转</p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>先判断，后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while_start:cmp a, bjxx while_end&#123;	; 代码&#125;jmp while_startwhile_end:; 后续代码</span><br></pre></td></tr></table></figure>
<p>通常为一个向下的条件跳转，该目的地之前有一个向上的实跳转，跳转到向下跳转前</p>
<h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp for_iffor_step:  步长for_if:  循环条件jxx for_endfor 代码jmp for_stepfor_end:</span><br></pre></td></tr></table></figure>
<p>很常见的代码，比while循环多一个向下跳转</p>
<h3 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h3><h4 id="加减法-1"><a href="#加减法-1" class="headerlink" title="加减法"></a>加减法</h4><p>add和sub指令，可用lea指令进行优化</p>
<p>此外还有<strong>常量折叠</strong>的优化方法，即编译时提前完成常量间的计算，节省运行消耗的时间</p>
<h4 id="乘法-1"><a href="#乘法-1" class="headerlink" title="乘法"></a>乘法</h4><p>imul为有符号乘法，mul为无符号乘法</p>
<p>通常使用lea比例因子寻址优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea edx, ds:0[rcx*4] ; *4imul edx, 7          ; *7lea edx, [rbc+rbc*8] ; *9</span><br></pre></td></tr></table></figure>
<h4 id="除法-1"><a href="#除法-1" class="headerlink" title="除法"></a>除法</h4><h5 id="有符号"><a href="#有符号" class="headerlink" title="有符号"></a>有符号</h5><p>除数为 $2^n$ 时，使用位移进行优化</p>
<p>除数为 $-2^n$ 时，使用位移，同时增加求补（x为负数时，计算 $-((x+(2^n-1))\gg n)$ ）</p>
<h4 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h4><h1 id="软件保护技术"><a href="#软件保护技术" class="headerlink" title="软件保护技术"></a>软件保护技术</h1><h2 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h2><p>序列号（注册码）的方式是目前最常见的一种保护</p>
<p>过程通常为：用户提交个人信息，公司计算得到序列号并返回给用户，用户通过序列号进行注册。软件从磁盘文件或注册表中获取注册信息</p>
<h3 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h3><h4 id="本地计算用户信息并与序列号比较"><a href="#本地计算用户信息并与序列号比较" class="headerlink" title="本地计算用户信息并与序列号比较"></a>本地计算用户信息并与序列号比较</h4><p>即：$序列号=F(用户名)$</p>
<p>对于这种方式，可以直接使用调试的手段，在内存中直接找到计算后的序列号，同时，将F函数复制出即可生成注册机</p>
<h4 id="通过注册码求逆并与用户信息比较"><a href="#通过注册码求逆并与用户信息比较" class="headerlink" title="通过注册码求逆并与用户信息比较"></a>通过注册码求逆并与用户信息比较</h4><p>即：用公式 $序列号=F(用户名)$ 生成，用公式 $用户名=F^{-1}(序列号)$ 验证</p>
<p>破解方法有</p>
<ul>
<li>通过 $F^{-1}$ 求出 $F$</li>
<li>给定用户名，穷举序列号</li>
<li>给定序列号，用 $F^{-1}$ 计算出用户名（通常包含不可见字符）</li>
</ul>
<h4 id="对等函数检查"><a href="#对等函数检查" class="headerlink" title="对等函数检查"></a>对等函数检查</h4><p>即：$F_1(用户名)=F_2(序列号)$</p>
<p>通常 $F_2$ 可逆，借鉴上两种破解思路即可</p>
<h4 id="二元函数"><a href="#二元函数" class="headerlink" title="二元函数"></a>二元函数</h4><p>即：$特定值=F(用户名，序列号)$</p>
<p>缺陷在于可能缺少用户名与序列号的一一对应关系，开发者不易写出注册机</p>
<h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><p>法一：通过跟踪输入，找到判断逻辑</p>
<blockquote>
<p>软件通常调用api将用户输入复制到缓冲区，常用api有：<code>GetWindowsTextA(W)</code>，<code>GetDiaItemTextA(W)</code>，<code>GetDlgItemInt</code>，<code>hmemcpy</code>，或者查找输出函数（对话框或标准输出等）</p>
</blockquote>
<p>法二：跟踪程序启动时对注册码的判断过程</p>
<blockquote>
<p>注册表中的序列号会调用 <code>RegQueryValueExA(W)</code>，INI文件中 <code>GetPrivateProfileStringA(W)</code>等等</p>
</blockquote>
<h4 id="根据数据约束性"><a href="#根据数据约束性" class="headerlink" title="根据数据约束性"></a>根据数据约束性</h4><p>对于采用明文比较的程序，正确注册码通常在输入注册码的前后 <code>90h</code> 字节的地方</p>
<h4 id="hmemcpy"><a href="#hmemcpy" class="headerlink" title="hmemcpy"></a>hmemcpy</h4><p>这个函数是 <code>Windows 9x</code> 系统的内部函数，是万能断点</p>
<p>现在同样可以使用系统的API下断点</p>
<h4 id="消息断点"><a href="#消息断点" class="headerlink" title="消息断点"></a>消息断点</h4><p>按下和释放鼠标时，会发送 <code>WM_LBUTTONDOWN (0201h)</code> 和 <code>WM_LBUTTONUP (0202h)</code> 消息</p>
<p>可以利用消息断点断在按钮的事件代码处</p>
<h4 id="人机交互信息"><a href="#人机交互信息" class="headerlink" title="人机交互信息"></a>人机交互信息</h4><p>软件大多数采用了人机对话的方式进行，因此可以直接通过搜索字符串和交叉引用找到关键函数</p>
<p>应该是目前最常用的方法了</p>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><ol>
<li>寄存器直接比较</li>
<li>函数比较</li>
<li>串比较</li>
</ol>
<p>串比较有些少见，记录一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lea edi []</span><br><span class="line">lea esi []</span><br><span class="line">repz cmpsd</span><br><span class="line">jz (jnz)</span><br></pre></td></tr></table></figure>
<h3 id="制作注册机"><a href="#制作注册机" class="headerlink" title="制作注册机"></a>制作注册机</h3><h4 id="明码泄露的攻击"><a href="#明码泄露的攻击" class="headerlink" title="明码泄露的攻击"></a>明码泄露的攻击</h4><p>序列号在内存中曾以明码出现过即可</p>
<p>可以使用keymake编写内存注册机，或利用 <code>Int 3</code> 等 <code>Debug API</code> 手写内存注册机</p>
<h4 id="无明码"><a href="#无明码" class="headerlink" title="无明码"></a>无明码</h4><p>进行加密算法的逆向解密</p>
<p>或者直接将汇编嵌入注册机中</p>
<h2 id="警告窗口"><a href="#警告窗口" class="headerlink" title="警告窗口"></a>警告窗口</h2><p>软件不时提醒用户购买正式版本</p>
<p>可以通过设置窗口为不可见来去除，或者在窗口的创建函数处将其跳过</p>
<p>利用 <code>Resource Hacker</code> 软件可以找到窗口的 id，然后再汇编中搜索即可找到窗口的程序</p>
<p>程序中，是否注册的 <code>flag</code> 标记可能是全局变量，找到这个变量并 patch 程序使其为 1 即可</p>
<h2 id="时间限制"><a href="#时间限制" class="headerlink" title="时间限制"></a>时间限制</h2><p>限制单次运行时长，或者限制软件的使用时间</p>
<h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><h4 id="setTimer-函数"><a href="#setTimer-函数" class="headerlink" title="setTimer() 函数"></a>setTimer() 函数</h4><p>程序运行时会申请一个计时器，并指定间隔，并获得一个处理计时器超时的回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">SetTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HWND hWnd,             <span class="comment">// 窗口句柄，计时器到时后，将向这个窗口发送WM_TIMER消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UINT nIDEvent,         <span class="comment">// 计时器标识</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UINT uElapse,          <span class="comment">// 指定计时器时间间隔（单位为毫秒）</span></span></span></span><br><span class="line"><span class="function"><span class="params">    TIMERPROC lpTimerFunc  <span class="comment">// 回调函数，超时后将调用</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="高精度计时器"><a href="#高精度计时器" class="headerlink" title="高精度计时器"></a>高精度计时器</h4><p>通过调用 <code>timeSecEvent()</code> 函数启动</p>
<h4 id="GetTickCount-函数及-timeGetTime-函数"><a href="#GetTickCount-函数及-timeGetTime-函数" class="headerlink" title="GetTickCount() 函数及 timeGetTime() 函数"></a>GetTickCount() 函数及 timeGetTime() 函数</h4><p>该函数返回系统自成功启动以来所经过的时间，将两次返回值相减，即可得到当前运行时间</p>
<p>这种方法也可以使用 <code>time()</code> 等函数</p>
<h3 id="时间限制-1"><a href="#时间限制-1" class="headerlink" title="时间限制"></a>时间限制</h3><p>软件通常将第一次运行时的系统时间，存放在注册表或文件或某扇区中，每次运行时获取该时间，并与当前时间进行比较</p>
<p>为了避免用户修改系统时间，软件会在保存安装时间（并存放于多个地方）之外，再保存最近一次运行的时间，每次运行时用当前时间替换</p>
<h3 id="拆解时间限制"><a href="#拆解时间限制" class="headerlink" title="拆解时间限制"></a>拆解时间限制</h3><ol>
<li>直接跳过 <code>SetTimer()</code> 函数</li>
<li>利用 <code>WM_TIMER</code> 消息，查找到时间比较的位置，对二进制文件进行patch（去掉退出跳转等等）</li>
</ol>
<blockquote>
<p>动态分析时，可以配合变速齿轮使用，这样就可以很快到达软件的限制时间，进行调试</p>
</blockquote>
<h2 id="菜单功能限制"><a href="#菜单功能限制" class="headerlink" title="菜单功能限制"></a>菜单功能限制</h2><p>当注册版和正式版文件相同，只是部分功能被限制无法使用时，可以恢复正式版的功能</p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><h4 id="EnableMenuItem"><a href="#EnableMenuItem" class="headerlink" title="EnableMenuItem()"></a>EnableMenuItem()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnableMenuItem</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HMENU hMenu,        <span class="comment">// 菜单句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UINT uIDEnableItem, <span class="comment">// 欲允许或禁止的一个菜单条目的标识符</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UINT uEnable,       <span class="comment">// 控制标志，包括允许、灰化、禁止等</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="EnableWindow"><a href="#EnableWindow" class="headerlink" title="EnableWindow()"></a>EnableWindow()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnableWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HWND hWnd,    <span class="comment">// 窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bEnable  <span class="comment">// True为允许，False为禁止</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="拆解菜单限制保护"><a href="#拆解菜单限制保护" class="headerlink" title="拆解菜单限制保护"></a>拆解菜单限制保护</h3><p>找到关键函数，把函数的参数patch一下即可</p>
<h2 id="KeyFile保护"><a href="#KeyFile保护" class="headerlink" title="KeyFile保护"></a>KeyFile保护</h2><p>KeyFile通常是一个小文件，可能是可见字符，也可能是二进制文件，由软件开发者定义</p>
<p>软件启动后，会从KeyFile文件中读取数据，根据处理结果判断是否正确注册</p>
<h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><p>与文件操作有关的API都可以下断点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>FindFirstFileA</td>
<td>确定注册文件是否存在</td>
</tr>
<tr>
<td>CreateFileA, _lopen</td>
<td>确定文件是否存在，打开文件以获得句柄</td>
</tr>
<tr>
<td>GetFileSize, GetFileSizeEx</td>
<td>获得文件的大小</td>
</tr>
<tr>
<td>GetFileAttributesA, GetFileAttributesExA</td>
<td>获得文件的属性</td>
</tr>
<tr>
<td>SetFilePointer, SetFilePointerEx</td>
<td>移动文件指针</td>
</tr>
<tr>
<td>ReadFile</td>
<td>读取文件内容</td>
</tr>
</tbody>
</table>
</div>
<h3 id="拆解保护"><a href="#拆解保护" class="headerlink" title="拆解保护"></a>拆解保护</h3><ol>
<li>利用文件监视软件找到KeyFile文件名</li>
<li>利用十六进制编辑器伪造KeyFile</li>
<li>动态调试，跟踪文件内容</li>
</ol>
<p>具体的破解方法与输入序列号类似</p>
<h2 id="网络验证"><a href="#网络验证" class="headerlink" title="网络验证"></a>网络验证</h2><p>软件必须从服务器中取得一些关键数据才能正确运行</p>
<p>破解的思路是拦截服务器的数据包，并分析程序对该数据包的处理</p>
<h3 id="相关API-1"><a href="#相关API-1" class="headerlink" title="相关API"></a>相关API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    SOCKET s,                 <span class="comment">// 套接字描述符</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> FAR *buf,      <span class="comment">// 缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> len,                  <span class="comment">// 发送数据的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> flags                 <span class="comment">// 附加标志，一般为0</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    SOCKET s,             <span class="comment">// 套接字描述符</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> FAR *buf,        <span class="comment">// 缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> len,              <span class="comment">// 缓冲区buf的长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> flags             <span class="comment">// 附加标志，一般为0</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>此外，还有微软扩展函数 <code>WSASend</code> 和 <code>WSARecv</code></p>
<h3 id="破解思路"><a href="#破解思路" class="headerlink" title="破解思路"></a>破解思路</h3><p>当服务器发送的数据包固定时，可以搭建本地服务器，发送该数据包</p>
<p>数据包不固定时，需要分析算法</p>
<h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><p>略</p>
<h1 id="Windows内核基础"><a href="#Windows内核基础" class="headerlink" title="Windows内核基础"></a>Windows内核基础</h1><h2 id="内核理论基础"><a href="#内核理论基础" class="headerlink" title="内核理论基础"></a>内核理论基础</h2><h3 id="权限级别"><a href="#权限级别" class="headerlink" title="权限级别"></a>权限级别</h3><p>CPU将权限分为 <code>R0~R3</code> 其中 <code>R0</code> 权限最高，运行内核，<code>R1</code> 和 <code>R2</code> 运行驱动程序，<code>R3</code> 权限最低，运行应用程序</p>
<p>操作系统（Windows, Linux）为方便，将内核和驱动程序（内核态）运行在了 <code>R0</code> 层，将应用程序（用户态）运行在 <code>R3</code> 层，而没有使用 <code>R1</code> 和 <code>R2</code> ，因此 <code>AMD64</code> 取消了 <code>R1</code> 和 <code>R2</code> 层</p>
<h3 id="内存空间布局"><a href="#内存空间布局" class="headerlink" title="内存空间布局"></a>内存空间布局</h3><p>32位系统虚拟内存：</p>
<p>2GB内核空间，64KB的NULL空间和非法空间，其余为进程空间</p>
<p>64位系统虚拟内存：</p>
<p>Windows实际为44位（16TB），Linux实际为48位（256TB）</p>
<p>存在大量空洞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+ 0x000000</span><br><span class="line">|                       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+ 0x400000</span><br><span class="line">|          text         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          data         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          BSS          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          heap         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+ 向下增长</span><br><span class="line">|                       |</span><br><span class="line">|          hole         |</span><br><span class="line">|                       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+ 0x00002AAAAAAAA000</span><br><span class="line">|      内存映射区域      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+ 向下增长</span><br><span class="line">|                       |</span><br><span class="line">|          hole         |</span><br><span class="line">|                       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+ 向上增长</span><br><span class="line">|         stack         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+ 0x00007FFFFFFFF000&#x3D;TASK_SIZE</span><br><span class="line">|       未定义区域       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+ 0xFFFF800000000000</span><br><span class="line">|        内核空间        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h3 id="Windows内核启动过程"><a href="#Windows内核启动过程" class="headerlink" title="Windows内核启动过程"></a>Windows内核启动过程</h3><p>BIOS+MBR+Windows</p>
<h4 id="启动自检"><a href="#启动自检" class="headerlink" title="启动自检"></a>启动自检</h4><p>从BIOS中载入必要指令，进行硬件初始化检查，并显示信息</p>
<h4 id="初始化启动"><a href="#初始化启动" class="headerlink" title="初始化启动"></a>初始化启动</h4><p>根据CMOS设置，BIOS加载启动盘，将引导代码载入内存，由MBR执行启动过程。启动代码搜索MBR的分区表，找到活动分区，将第一个扇区的引导代码载入内存，检测系统并查找启动管理器。过去为 <code>ntldr</code> ，Windows7开始使用 <code>Bootmgr</code>作为启动管理。</p>
<h4 id="Boot加载"><a href="#Boot加载" class="headerlink" title="Boot加载"></a>Boot加载</h4><p>对启动管理器进行设置</p>
<ul>
<li>设置内存模式：32位系统+32位CPU，设置为32位内存模式；64位系统+64位CPU，设置为64位内存模式</li>
<li>启动一个简单的文件系统：定位 <code>boot.ini</code>，<code>ntoskrnl</code>，<code>Hal</code> 等启动文件</li>
<li>读取 <code>boot.ini</code> 文件</li>
</ul>
<h4 id="检测和配置硬件"><a href="#检测和配置硬件" class="headerlink" title="检测和配置硬件"></a>检测和配置硬件</h4><p>检查和配置硬件设备，如系统固件、总线、适配器、键盘磁盘等等</p>
<h4 id="内核加载"><a href="#内核加载" class="headerlink" title="内核加载"></a>内核加载</h4><p>启动管理器先加载内核 <code>Ntoskrnl.exe</code> 和硬件抽象层 <code>HAL</code>。<code>HAL</code> 会对硬件底层进行隔离，为操作系统提供统一的API。</p>
<p>随后根据注册表 <code>HKEY_LOCAL_MACHINE\System\CurrentControlSet</code> 来加载驱动程序</p>
<p>注册表中的 <code>Start</code> 键表示了启动顺序</p>
<ol>
<li><code>SERVICE_BOOT_START</code>， 内核初始化时，与系统核心相关的重要驱动程序</li>
<li><code>SERVICE_SYSTEM_START</code></li>
<li><code>SERVICE_AUTO_START</code>，登陆界面开始</li>
<li><code>SERVICE_DEMAND_START</code>，需要时手动加载</li>
<li><code>SERVICE_DISABLED</code>，禁止加载</li>
</ol>
<h4 id="Windows会话管理启动"><a href="#Windows会话管理启动" class="headerlink" title="Windows会话管理启动"></a>Windows会话管理启动</h4><p><code>smss.exe</code> 是Windows中第一个创建的用户模式进程，主要用于</p>
<ul>
<li>创建系统环境变量</li>
<li>加载 <code>win32k.sys</code>，Windows子系统的内核模式部分</li>
<li>启动 <code>csrss.exe</code>，Windows子系统的用户模式部分</li>
<li>启动 <code>winlogon.exe</code></li>
<li>创建虚拟内存页面文件</li>
<li>执行重启前未完成的重命名工作</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Reverse/" rel="tag"># Reverse</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/09/21/BUUOJ%E9%83%A8%E5%88%86RE%EF%BC%88%E5%9B%9B%EF%BC%89-pycdc-bug%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/" rel="prev" title="BUUOJ部分RE（四）&& pycdc bug简单记录">
      <i class="fa fa-chevron-left"></i> BUUOJ部分RE（四）&& pycdc bug简单记录
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/26/DASCTF-2021-09-Writeup/" rel="next" title="DASCTF 2021-09 Writeup">
      DASCTF 2021-09 Writeup <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E7%9A%84%E4%B8%80%E8%88%AC%E9%80%94%E5%BE%84%E5%92%8C%E7%AD%96%E7%95%A5"><span class="nav-number">1.1.</span> <span class="nav-text">分析的一般途径和策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%AD%97%E7%AC%A6"><span class="nav-number">1.2.</span> <span class="nav-text">文本字符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ASCII-%E5%92%8C-Unicode"><span class="nav-number">1.2.1.</span> <span class="nav-text">ASCII 和 Unicode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E5%AD%98%E5%82%A8%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">字节存储顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows"><span class="nav-number">1.3.</span> <span class="nav-text">Windows</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Win-32-API"><span class="nav-number">1.3.1.</span> <span class="nav-text">Win 32 API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.2.</span> <span class="nav-text">Windows消息机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SendMessage"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">SendMessage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WM-COMMAND"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">WM_COMMAND</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WM-DESTORY"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">WM_DESTORY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WM-GETTEXT"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">WM_GETTEXT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WM-QUIT"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">WM_QUIT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WM-LBUTTONDOWN"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">WM_LBUTTONDOWN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">1.3.3.</span> <span class="nav-text">虚拟内存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="nav-number">2.</span> <span class="nav-text">动态分析技术</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="nav-number">3.</span> <span class="nav-text">逆向分析技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Win32"><span class="nav-number">3.1.</span> <span class="nav-text">Win32</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8"><span class="nav-number">3.1.1.</span> <span class="nav-text">启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">3.1.2.</span> <span class="nav-text">函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">3.1.3.</span> <span class="nav-text">参数传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8D%E7%A7%B0%E4%BF%AE%E9%A5%B0%E7%BA%A6%E5%AE%9A"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">名称修饰约定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">3.1.4.</span> <span class="nav-text">返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#return%E6%93%8D%E4%BD%9C%E8%BF%94%E5%9B%9E"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">return操作返回</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E8%BF%94%E5%9B%9E"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">传引用方式返回</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.5.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">3.1.5.1.</span> <span class="nav-text">局部变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E5%AD%98%E6%94%BE"><span class="nav-number">3.1.5.1.1.</span> <span class="nav-text">栈存放</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%AD%98%E6%94%BE"><span class="nav-number">3.1.5.1.2.</span> <span class="nav-text">寄存器存放</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">3.1.5.2.</span> <span class="nav-text">全局变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">3.1.5.3.</span> <span class="nav-text">数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.6.</span> <span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.1.7.</span> <span class="nav-text">控制语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#if-else"><span class="nav-number">3.1.7.1.</span> <span class="nav-text">if-else</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch-case"><span class="nav-number">3.1.7.2.</span> <span class="nav-text">switch-case</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E6%9C%BA%E5%99%A8%E7%A0%81%E8%AE%A1%E7%AE%97"><span class="nav-number">3.1.7.3.</span> <span class="nav-text">转移指令机器码计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">3.1.7.4.</span> <span class="nav-text">条件设置指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.1.8.</span> <span class="nav-text">循环语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="nav-number">3.1.9.</span> <span class="nav-text">数学运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="nav-number">3.1.9.1.</span> <span class="nav-text">加减法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%98%E6%B3%95"><span class="nav-number">3.1.9.2.</span> <span class="nav-text">乘法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%A4%E6%B3%95"><span class="nav-number">3.1.9.3.</span> <span class="nav-text">除法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.1.10.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8"><span class="nav-number">3.1.10.1.</span> <span class="nav-text">字符串存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%AF%BB%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="nav-number">3.1.10.2.</span> <span class="nav-text">字符寻址指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ASCII%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.1.10.3.</span> <span class="nav-text">ASCII大小写转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E9%95%BF%E5%BA%A6"><span class="nav-number">3.1.10.4.</span> <span class="nav-text">计算长度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E4%BF%AE%E6%94%B9%E6%8A%80%E5%B7%A7"><span class="nav-number">3.1.11.</span> <span class="nav-text">指令修改技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64%E4%BD%8D"><span class="nav-number">3.2.</span> <span class="nav-text">64位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88-1"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AEstart%E5%AF%BB%E6%89%BEmain"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">根据start寻找main</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">调用约定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">函数返回值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">3.2.3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-1"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-1"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">全局变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-1"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-1"><span class="nav-number">3.2.4.</span> <span class="nav-text">控制语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5-1"><span class="nav-number">3.2.5.</span> <span class="nav-text">循环语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#do-while"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">do while</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">while循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.2.5.3.</span> <span class="nav-text">for 循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.2.6.</span> <span class="nav-text">数学运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%87%8F%E6%B3%95-1"><span class="nav-number">3.2.6.1.</span> <span class="nav-text">加减法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%98%E6%B3%95-1"><span class="nav-number">3.2.6.2.</span> <span class="nav-text">乘法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%A4%E6%B3%95-1"><span class="nav-number">3.2.6.3.</span> <span class="nav-text">除法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7"><span class="nav-number">3.2.6.3.1.</span> <span class="nav-text">有符号</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%96%E6%A8%A1"><span class="nav-number">3.2.6.4.</span> <span class="nav-text">取模</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF"><span class="nav-number">4.</span> <span class="nav-text">软件保护技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="nav-number">4.1.</span> <span class="nav-text">序列号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-number">4.1.1.</span> <span class="nav-text">保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E8%AE%A1%E7%AE%97%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%B9%B6%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8F%B7%E6%AF%94%E8%BE%83"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">本地计算用户信息并与序列号比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%B3%A8%E5%86%8C%E7%A0%81%E6%B1%82%E9%80%86%E5%B9%B6%E4%B8%8E%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%AF%94%E8%BE%83"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">通过注册码求逆并与用户信息比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E7%AD%89%E5%87%BD%E6%95%B0%E6%A3%80%E6%9F%A5"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">对等函数检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.1.4.</span> <span class="nav-text">二元函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.2.</span> <span class="nav-text">攻击方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E7%BA%A6%E6%9D%9F%E6%80%A7"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">根据数据约束性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hmemcpy"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">hmemcpy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%96%AD%E7%82%B9"><span class="nav-number">4.1.2.3.</span> <span class="nav-text">消息断点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E4%BF%A1%E6%81%AF"><span class="nav-number">4.1.2.4.</span> <span class="nav-text">人机交互信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="nav-number">4.1.3.</span> <span class="nav-text">字符串比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%B6%E4%BD%9C%E6%B3%A8%E5%86%8C%E6%9C%BA"><span class="nav-number">4.1.4.</span> <span class="nav-text">制作注册机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%8E%E7%A0%81%E6%B3%84%E9%9C%B2%E7%9A%84%E6%94%BB%E5%87%BB"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">明码泄露的攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E6%98%8E%E7%A0%81"><span class="nav-number">4.1.4.2.</span> <span class="nav-text">无明码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AD%A6%E5%91%8A%E7%AA%97%E5%8F%A3"><span class="nav-number">4.2.</span> <span class="nav-text">警告窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E9%99%90%E5%88%B6"><span class="nav-number">4.3.</span> <span class="nav-text">时间限制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="nav-number">4.3.1.</span> <span class="nav-text">计时器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#setTimer-%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">setTimer() 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">高精度计时器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GetTickCount-%E5%87%BD%E6%95%B0%E5%8F%8A-timeGetTime-%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.1.3.</span> <span class="nav-text">GetTickCount() 函数及 timeGetTime() 函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E9%99%90%E5%88%B6-1"><span class="nav-number">4.3.2.</span> <span class="nav-text">时间限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%86%E8%A7%A3%E6%97%B6%E9%97%B4%E9%99%90%E5%88%B6"><span class="nav-number">4.3.3.</span> <span class="nav-text">拆解时间限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8F%9C%E5%8D%95%E5%8A%9F%E8%83%BD%E9%99%90%E5%88%B6"><span class="nav-number">4.4.</span> <span class="nav-text">菜单功能限制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.1.</span> <span class="nav-text">相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#EnableMenuItem"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">EnableMenuItem()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EnableWindow"><span class="nav-number">4.4.1.2.</span> <span class="nav-text">EnableWindow()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%86%E8%A7%A3%E8%8F%9C%E5%8D%95%E9%99%90%E5%88%B6%E4%BF%9D%E6%8A%A4"><span class="nav-number">4.4.2.</span> <span class="nav-text">拆解菜单限制保护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KeyFile%E4%BF%9D%E6%8A%A4"><span class="nav-number">4.5.</span> <span class="nav-text">KeyFile保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3API"><span class="nav-number">4.5.1.</span> <span class="nav-text">相关API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%86%E8%A7%A3%E4%BF%9D%E6%8A%A4"><span class="nav-number">4.5.2.</span> <span class="nav-text">拆解保护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81"><span class="nav-number">4.6.</span> <span class="nav-text">网络验证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3API-1"><span class="nav-number">4.6.1.</span> <span class="nav-text">相关API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%B4%E8%A7%A3%E6%80%9D%E8%B7%AF"><span class="nav-number">4.6.2.</span> <span class="nav-text">破解思路</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">加密算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Windows%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80"><span class="nav-number">6.</span> <span class="nav-text">Windows内核基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">6.1.</span> <span class="nav-text">内核理论基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E7%BA%A7%E5%88%AB"><span class="nav-number">6.1.1.</span> <span class="nav-text">权限级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="nav-number">6.1.2.</span> <span class="nav-text">内存空间布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">6.1.3.</span> <span class="nav-text">Windows内核启动过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E8%87%AA%E6%A3%80"><span class="nav-number">6.1.3.1.</span> <span class="nav-text">启动自检</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%AF%E5%8A%A8"><span class="nav-number">6.1.3.2.</span> <span class="nav-text">初始化启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Boot%E5%8A%A0%E8%BD%BD"><span class="nav-number">6.1.3.3.</span> <span class="nav-text">Boot加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%92%8C%E9%85%8D%E7%BD%AE%E7%A1%AC%E4%BB%B6"><span class="nav-number">6.1.3.4.</span> <span class="nav-text">检测和配置硬件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BD"><span class="nav-number">6.1.3.5.</span> <span class="nav-text">内核加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E5%90%AF%E5%8A%A8"><span class="nav-number">6.1.3.6.</span> <span class="nav-text">Windows会话管理启动</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="s0uthwood"
      src="/images/avatar3.jpg">
  <p class="site-author-name" itemprop="name">s0uthwood</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://psyduck0409.github.io/" title="https:&#x2F;&#x2F;psyduck0409.github.io&#x2F;" rel="noopener" target="_blank">DaiDai</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://justloseit.top/" title="http:&#x2F;&#x2F;justloseit.top&#x2F;" rel="noopener" target="_blank">Joker</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kfxp12138.github.io/" title="https:&#x2F;&#x2F;kfxp12138.github.io&#x2F;" rel="noopener" target="_blank">triplewings</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://fyhssgss.github.io/" title="https:&#x2F;&#x2F;fyhssgss.github.io&#x2F;" rel="noopener" target="_blank">FYHSSGSS</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://xz1548.github.io/" title="https:&#x2F;&#x2F;xz1548.github.io&#x2F;" rel="noopener" target="_blank">Zhr</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://newbiereer.github.io/" title="https:&#x2F;&#x2F;newbiereer.github.io&#x2F;" rel="noopener" target="_blank">NewBieReer</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">s0uthwood</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">333k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:03</span>
</div>
  <div class="powered-by">Powered By - <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>

        








      </div>
    </footer>
  </div>

  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
